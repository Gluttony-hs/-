<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【模板】Polya定理]]></title>
    <url>%2F2019%2F05%2F03%2F%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91Polya%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[【模板】Polya定理传送门洛谷 题目描述给定一个$n$个点，$n$条边的环，有$n$种颜色，给每个顶点染色，问有多少种本质不同的染色方案，答案对$10^9+7$取模。 注意本题的本质不同，定义为：只需要不能通过旋转与别的染色方案相同。 输入输出格式输入格式：第一行输入一个$t$，表示有$t$组数据。 第二行开始，一共$t$行，每行一个整数$n$，意思如题所示。 输出格式：共$t$行，每行一个数字，表示染色方案数对$10^9+7$取模后的结果。 输入输出样例输入样例#1：512345 输出样例#1：131170629 说明$n \leq 10^9$$t \leq 10^3$ 分析$Burnside$引理对于每个置换$g$，我们定义$C(g)$为在置换$g$下保持不变的方案数。则有： 本质不同的方案数为$C(g)$的平均数。即： ans=\frac{1} {\left | G \right |} \sum _ { g \in G} C(g)证明需要用到群论，本蒟蒻不是很会，就不现丑了。 $Polya$定理$Polya$定理其实是对$Burnside$引理的具体化，提供了计算不动点的具体方法。由于$Burnside$引理每次需要枚举状态，显然无法让人接受。于是，$Polya$定理出现了。假设一个置换有$k$个循环，易知每个循环对应的所有位置颜色需一致，而任意两个循环之间选什么颜色互不影响。因此，如果有$m$种可选颜色，则该置换对应的不动点个数为$m^k$。用其替换$Burnside$引理中的$C(g)$，即$C(g)=m^k$。得到等价类数目为： \frac{1} {\left | G \right |} \sum _ {i=0} ^ {\left | G \right | } m ^ {k_i}其中$\left | G \right |$表示置换的数目，$k_i$表示第$i$个置换包含的循环个数。 本题考虑第$i$次旋转。显然一个的循环节长度是$\frac{lcm(n,i)}{i}$，形象的，想象你有一条长$i$的线段用来倍长，因为我们总长为$n$，所以倍长后的结果一定被$n$整除，那我们就将干脆设最终的长度的$lcm(n,i)$，而我们每次只能从一条长$i$的线段中取一个放入我们的循环中，那么我们的循环自然为$\frac{lcm(n,i)}{i}$。既然每个循环节长度是$\frac{lcm(n,i)}{i}$，我们有$n$个数放入循环节中，那么循环节个数就是$\frac{n}{\frac{lcm(n,i)}{i}}$，即$gcd(n,i)$。所以： ans=\frac{1} {\left | G \right |} \sum _ {i=0} ^ {\left | G \right | } m ^ {gcd(n,i)}再向式子中带入本题变量，得： ans=\frac{1} {n} \sum _ {i=0} ^ n n ^ {gcd(n,i)}但这样是过不了的，我们还要优化一波。 ans=\frac{1} {n} \sum _ {i=0} ^ n n ^ {gcd(n,i)} \\ = \frac{1} {n} \sum _ {j|n} ^ n n ^ j \sum _ {i=1} ^ {n} {[gcd(n,i) == j]} \\ = \frac{1} {n} \sum _ {j|n} ^ n n ^ j \sum _ {i=1} ^ { \frac{n}{j} } {[gcd(n,i \times j) == j]} \\ = \frac{1} {n} \sum _ {j|n} ^ n n ^ j \sum _ {i=1} ^ { \frac{n}{j} } {[gcd( \frac{n}{j} ,i) == 1]} \\ = \frac{1} {n} \sum _ {j|n} ^ n n ^ j \varphi ( \frac{n}{j} )其中$\varphi$为欧拉函数，我们可以在$O(\sqrt n)$的时间内求出。 参考资料$Burnside$引理 &amp; $Polya$定理QAQqwe的 Burnside引理与Polya定理TenderRun的我对Burnside定理的理解周道-Althen的 超低能解读群论 本题SLF_LLL_SPFA的洛谷题解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define p 1000000007template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int T,n;int fpow(int x,int y)&#123; int ans=1; while(y) &#123; if(y&amp;1)ans=(1ll*ans*x)%p; x=(1ll*x*x)%p; y&gt;&gt;=1; &#125; return ans;&#125;int phi(int x)&#123; int ans=x; for(int i=2;i*i&lt;=x;i++) &#123; if(x%i==0) &#123; ans=ans/i*(i-1); while(x%i==0)x/=i; &#125; &#125; if(x!=1)ans=ans/x*(x-1); return ans%p;&#125;int main()&#123; T=read&lt;int&gt;(); for(int tot=1;tot&lt;=T;tot++) &#123; n=read&lt;int&gt;(); int ans=0; for(int i=1;i*i&lt;=n;i++) if(n%i==0) &#123; ans=(ans+(1ll*fpow(n,i)*phi(n/i))%p)%p; if(n/i!=i)ans=(ans+(1ll*fpow(n,n/i)*phi(i))%p)%p; &#125; ans=(1ll*ans*fpow(n,p-2))%p; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>Polya定理</tag>
        <tag>Burnside引理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2197 【模板】nim游戏]]></title>
    <url>%2F2019%2F05%2F03%2FP2197-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91nim%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[P2197 【模板】nim游戏传送门洛谷 题目描述甲，乙两个人玩$Nim$取石子游戏。 $nim$游戏的规则是这样的：地上有$n$堆石子（每堆石子数量小于$10000$），每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这$n$堆石子的数量，他想知道是否存在先手必胜的策略。 输入输出格式输入格式：第一行一个整数$T \le 10$,表示有$T$组数据 接下来每两行是一组数据，第一行一个整数$n$，表示有$n$堆石子，$n \le 10000$; 第二行有$n$个数，表示每一堆石子的数量 输出格式：共$T$行，如果对于这组数据存在先手必胜策略则输出”$Yes$”,否则输出”$No$”，不包含引号，每个单词一行。 输入输出样例输入样例#1：221 121 0 输出样例#1：NoYes 分析本题可以就题论题，但本文对本题不做过多证明（我才不会告诉你是我证不来）。介绍比较通用的解法——博弈$SG$。 博弈SG简介公平游戏是一种双人游戏，在游戏中双方都有完整的信息，没有牵涉，任何状态的合法操作对双方来说都是相同的。而在公平游戏中，$SG$函数和$SG$定理是一个十分神奇的东西，有了它，绝大部分的博弈都可以被统一到这个上面，都可以使用SG函数解决。是一种解决博弈问题的十分方便的手段。 前置知识首先，我们定义$mex$运算（排斥运算），其运算结果是传入参数中没有出现的第一个非负整数。举个例子：$mex(1,2,3)=0$ $mex(0,1,2)=3$ $mex(0,2,3)=1$很好理解，对吧？我们可以抽象一下。由于博弈是单人游戏，而且有“双方都做出最优决策”这一点限制了，所以最后的结果只取决于你面对的局面。很简单，如果结果像象棋一样取决与你和对手的策略（不一定最优），那还叫你做什么，这又不是交互式题目。开始即结束，大家一开始就知道结果了，是不是有点凄凉？那么我们所谓的SG值其实是指这一局面的SG值。既然我们的SG值只取决于局面，那我们将局面看作一个个点，如果我们有操作可以使得局面$A$变成局面$B$，那么我们在局面$A$所代表的点和局面$B$所代表的点连边，方向从局面$A$所代表的点和局面$B$所代表的点，同时我们称状态$B$是状态$A$的后继状态。然后画画图，我们发现，这就是个$DAG$。 $\uparrow$ 图来自龙杉老师的Sprague-Grundy Function-SG函数—博弈论(3)。 然后我们定义的$P$状态和$N$状态。$P$状态（Positive状态），指在这一局面下存在使操作者胜利的操作方法。$N$状态（Negative状态），指在这一局面下不存在存在使操作者胜利的操作方法。其中汇点是$P$状态。那么我们考虑如何推导当前状态。有一个很显然的定理（不知道算不算定理，姑且算定理）。对于每一个$P$状态，它的后继状态一定全是$N$状态。对于每一个$N$状态，它的后继状态有一部分是$P$状态。逆定理也成立。口胡证明一波，如果当前状态的后继状态有$P$状态，那么根据“双方都做出最优决策”限制，对手一定会做操作将当前状态变成后继状态中的$P$状态，那么你就挂了，所以是$N$状态，而如果当前状态的后继状态全是$N$状态，对手怎么操作都是$N$状态，那么它就挂了，所以是$P$状态。 $\uparrow$ 图来自龙杉老师的Sprague-Grundy Function-SG函数—博弈论(3)。 现在就介绍$Sprague-Grundy$定理（$SG$定理）：如果$Game_1$和$Game_2$是公平游戏，那么他们的总游戏是另一个公平游戏（$Game_1$和$Game_2$是子游戏）。总游戏规则：在每个回合，一个玩家玩其中一个游戏，不碰另一个游戏。当 $Game_1$ 和 $Game_2$ 都结束时总游戏结束。 如果 $Graph_1 = (V_1, E_1)$ 和 $Graph_2 = (V_2, E_2)$是$Game_1$和$Game_2$分别的$DAG$，那么我们将总游戏 $Graph = (V _ {sum}, E _ {sum}) $规定为： V _ {sum} = V1 \cup V2 \\ E _ {sum} = E1 \cup E2如果我们有这两个游戏的$DAG$——$Graph_1$和$Graph_2$。并且我们知道单个游戏的P-状态和N-状态。那么我们能够知道总游戏的$DAG$吗？显然不行。不难看出两个P-状态的和总是P-状态，P-状态和N-状态的和总是N-状态。但是两个N-状态的和既可能是P-状态也可能是N-状态。因此，只知道单个游戏的P-状态和N-状态是不够的。 所以为了正确地玩游戏和我们需要推广$P$状态和$N$状态，它就是$Sprague-Grudy$函数（$SG$函数）。我们定义$SG$函数的值$SG_x = mex ( SG_y ) | (x,y) \in E _ {sum}$。 $\uparrow$ 图来自龙杉老师的Sprague-Grundy Function-SG函数—博弈论(3)。 那么它有什么性质吗？肯定有啊。 性质1：点$x$是$P$状态当且仅当$SG_x=0$性质2：如果$Graph = Graph_1 + Graph_2$且 点$x = x_1+x_2$ 是$Graph$的一个点，那么$SG_x$ 为$SG _ {x_1}$ 和 $SG _ {x_2}$ 在二进制下的异或：即 g(v) = g(v1) \oplus g(v2).也称作$nim$和。 实现对于一个游戏，我们先将其分为几个互不相干的子游戏，求出每个子游戏的$SG$值，再用$nim$和合并一下就知道了总游戏的状态，然后看看是$P$态还是$N$态就知道结果了。嗯…似乎很有道理。但子游戏的$SG$值怎么求呢？ 1.可选步数为1~m的连续整数，直接取模即可，SG(x) = x % (m+1);2.可选步数为任意步，SG(x) = x;3.可选步数为一系列不连续的数，用模板计算。方法一：打表 $f[]$可以取走的石子个数,注意$f[]$需要从小到大排序 $sg[]$$SG$函数值；$vis[]$标记数组，用于求$mex{}$1234567891011121314151617181920int f[MAXN],sg[MAXN];bool vis[MAXN];void getSG(int n)&#123; sort(f+1,f+1+n); memset(sg,0,sizeof(sg)); for (int i=1; i&lt;=n; i++) &#123; memset(vis,0,sizeof(vis)); for (int j=1; f[j]&lt;=i; j++)//f排序是为了让每一种取法都循环到 vis[sg[i-f[j]]]=1; for (int j=0; j&lt;=n; j++) &#123; if (vis[j]==0) &#123; sg[i]=j; break; &#125; &#125; &#125;&#125; 方法二：$dfs$ $s$数组是定义特殊取法规则的数组，注意要按照从小到大排序；$n$表示集合大小 $SG$函数要初始化为$-1$，每个集合只需初始化一遍1234567891011121314151617181920212223int s[MAXN],sg[MAXN],n;bool vis[MAXN];int SG_dfs(int x)&#123; if (sh[x]!=-1) return sg[x]; memset(vis,0,sizeof(vis)); for (int i=0; i&lt;n; i++) &#123; if (x&gt;=s[i]) &#123; SG_dfs(x-s[i]); vis[sg[x-s[i]]]=1; &#125; &#125; int i=0; while (1) &#123; if (!vis[i]) return sg[x]=i; i++; &#125;&#125; $\uparrow$ 方法和代码来自秋日私语的洛谷题解。 本题说了这么多，还是要回归本题。首先分解本题的子问题，就是一堆$n$个石子，两人分别取石子知道没有办法再取游戏结束。根据$SG$函数值求法第2条：$SG_n=n$于是用$nim$和搞出本题总$SG$函数值。即 SG_{sum} = SG_{x_1} \oplus SG_{x_2} \oplus ... \oplus SG_{x_n} \\ = x_1 \oplus x_2 \oplus ... \oplus x_n再用$SG$函数值的性质判状态。这就是本题解法的来历。博弈$SG$一波带走。之前没学过博弈$SG$的时候一直不知道这个简单的异或做法是怎么来的，结果学了博弈$SG$就是道水题。 参考资料博弈SG龙杉老师的 Sprague-Grundy Function-SG函数—博弈论(3) 讲的非常详细。秋日私语的 [学习笔记] （博弈论）Nim游戏和SG函数 有经典模型和题目总结。Enstein_Jun的 组合游戏 - SG函数和SG定理Must_so的 ACM博弈学习小结Flying_Fatty的 博弈 SG函数 拓展资料自为风月马前卒的 博弈论进阶之Multi-SG自为风月马前卒的 博弈论进阶之Every-SGmyjs999的 博弈论 SG函数 SG定理kuangbin的 【转】博弈-翻硬币游戏celia01的 由poj 1067引发的——取石子游戏【各类取石子总结】 各类博弈问题的总结。 本题秋日私语的洛谷题解 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int T,n;int main()&#123; T=read&lt;int&gt;(); for(int tot=1;tot&lt;=T;tot++) &#123; n=read&lt;int&gt;(); int tmp=0; for(int i=1;i&lt;=n;i++)tmp^=read&lt;int&gt;(); puts(tmp? "Yes":"No"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>博弈SG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4718 【模板】Pollard-Rho算法]]></title>
    <url>%2F2019%2F05%2F02%2FP4718-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91Pollard-Rho%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[P4718 【模板】Pollard-Rho算法传送门洛谷 题目描述Miller Rabin算法是一种高效的质数判断方法。虽然是一种不确定的质数判断法，但是在选择多种底数的情况下，正确率是可以接受的。 Pollard Rho是一个非常玄学的方式，用于在$O(n^{1/4})$的期望时间复杂度内计算合数n的某个非平凡因子。事实上算法导论给出的是$O(\sqrt p)$，$p$是$n$的某个最小因子，满足$p$与$n/p$互质。但是这些都是期望，未必符合实际。但事实上Pollard Rho算法在实际环境中运行的相当不错。 这里我们要写一个程序，对于每个数字检验是否是质数，是质数就输出Prime；如果不是质数，输出它最大的质因子是哪个。 输入输出格式输入格式：第一行，$T$代表数据组数（不大于$350$） 以下$T$行，每行一个整数$n$，保证$1\le n\le 10^{18}$。 输出格式：输出$T$行。 对于每组测试数据输出结果。 输入输出样例输入样例#1：6213134889712345676543211000000000000 输出样例#1：PrimePrime674146495 分析先讲讲算法。 Miller-Rabin算法简介Miller-Rabin算法是一种可以快速判定大质数的随机算法，有一定概率阵亡。嗯…好像讲完了。 前置知识首先，我们需要知道一个定理——费马小定理。 a^{p-1} \equiv 1 \pmod{m}其次，我们还需要知道一个定理(不知道算不算定理，以下姑且将其称为定理)对于一个奇质数$p$且$e \ge 1$，满足$a^2 \equiv 1 \pmod {p^e}$的根只有平凡平方根。严格的证明不会，口胡一下还是会的。首先我们化式子。 a^2 \equiv 1 \pmod {p^e} a^2-1 \equiv 0 \pmod {p^e} (a+1) \times (a-1) \equiv 0 \pmod {p^e}即，$p \mid (a+1)$或者$p \mid (a-1)$。然后分情况讨论再合并，就是上面这个东西了。于是Miller和Rabin就捣鼓出了传说中的Miller-Rabin素性测试算法。 实现Miller-Rabin算法的主体思路很简单。首先，随机一个数$a$。想想费马小定理，我们想知道一个数$n$是不是素数，就验证一下$a^{n-1} \equiv 1 \pmod p$这个式子是否成立。但这样是有几率误判的（因为费马小定理的逆定理本来就是错的）。如取$a=2$，在前10亿个自然数中共有50847534个素数，而满足$2^{n-1} \equiv 1 \pmod p$的合数有5597个。这样算下来，算法出错的可能性约为0.00011。我们无法接受。无法接受归无法接受，我们还是得用它。所以想办法提升它的正确性。还记得第二条定理吗？我们将$a^{p-1}$拆开，拆成$a^{d \times 2^s}$，那么就像相当于将$a^d$一直平方，就可以套第二个式子了。当然能通过上面两个定理的检验的假素数还是有的（藏在数群中带着素数的面具勾搭素MM）。所以，我们还需要多次取数检验提高正确率。通常认为，Miller-Rabin算法中随机选取$ k$个底数进行测试的失误率大概为$4^{-k}$。 Miller-Rabin算法中，一般情况下底数随机选取，但当待测数不太大时，选择测试底数就有一些技巧了。比如，如果被测数小于$4759123141$，那么只需要测试三个底数$2, 7$和$61$就足够了。如果你每次都用前$7$个素数($2, 3, 5, 7, 11, 13$和$17$)进行测试，所有不超过$341550071728320$的数都是正确的。如果选用$2, 3, 7, 61$和$24251$作为底数，那么$10^{16}$内唯一的强伪素数为$46856248255981$。这样的一些结论使得Miller-Rabin算法在OI中非常实用。$\uparrow$ 这段底数选取的数据来自Norlan的素数与素性测试（Miller-Rabin测试）。 Pollard-Rho算法Pollard-Rho算法的主要思想是找因子分解，这个因子不一定是质因子。那么问题就在于如何找到它的因子。首先我们知道Pollard-Rho算法是一个随机算法，那么我们找因子自然是随机。但每次生成一个数显然撞上的可能性太小，那么根据生日悖论，我们每次多生成一些的话，且每次我们尝试的数为$x-y$（$x,y$为我们生成的随机数，下文一样），撞上的可能性就会增加。但这样我们又面临这一个问题，我们的程序可以调用的内存是有限的，如果我们每次生成很多数，空间就爆炸了。真是一个令人尴尬的问题。好在已经被解决了，要不然要这算法有何用。因为我们每次只调用两个随机数，提前把全部随机数生成好毫无意义。那么我们就按照一定顺序生成数。于是就有了一个伪随机数生成函数—— f(x)=x^2+a \pmod n其中$a$是我们随机的一个数（个人觉得很像随机种子）。那么我们就用了一系列随机数，还不用将其全部存放与内存中。但Pollard-Rho算法的精髓还不止这一点。我们发现尽管生成了一串随机数，但要求能整除$n$，这样的数被撞上的概率还是不足以让人满意。于是Pollard又想出了一个办法。概率不然人满意，是不是我们对生成的数要求太高了。那换个要求，我们要求$gcd(x-y,n)&gt;1$。这样的数又$x,2x,…,(y-1)x,y,2y,…,(x-1)y$，共$x+y-2$个数。于是成功率可以让人接受了。但算法还是不怎么完美，因为我们的伪随机数生成函数是长这样的。$\uparrow$ 图来自 努力努力再努力x 的 大数因式分解 Pollard_rho 算法详解 很像希腊字母$\rho$，这也是算法名字中Rho的来历。于是新的问题再次被提了出来。怎么判断环？？？如果把生成的数都存下来判环，我们使用这个函数的意义就没有了。好在前人已经帮我们解决了这个问题。我们可以使用Floyd判环法。想象两个人A,B在一个环形跑道上奔跑，我们让A的速度是B的两倍，当A第一次赶上B时，我们就知道B一定比A多跑了一圈。但实际应用中我们采用的是brent判环法（因为更高效），具体的，就是倍增，让A每次比B多跑$2^i$步。吐槽：我说我怎么看不懂他们在写什么，原来是因为我不知道我写的是brent判环法，还以为我们都是用的Floyd判环法。 连判环法都认不出来的蒟蒻一只，还有，觉得Floyd判环法好丑好麻烦。来来来，我们分析一波复杂度。根据生日悖论，每 $k = \sqrt n$个人中有 50%的可能性产生生日冲突的话。那么这个算法的期望复杂度应该是带一个根号的，粗略的说，我们试一个数，原来试到的概率为$\frac{1}{n}$，加上生日悖论的话，变成$\sqrt \frac {1}{n}$，现在有$x+y-2$个数可以成功，再乘一下，概率还是比较大。所以期望复杂度感觉上虽然带个根号，当应该不会很高。事实上，算法导论上给出的期望复杂度为$O( \sqrt p )$，$p$为$n$的某个最小因子，满足$p$与$n/p$互质。证明见算法导论。好像还可以当作$O( n ^ \frac{1}{4} )$来算。 参考资料Miller-Rabin算法努力努力再努力x的 大素数测试的Miller-Rabin算法Norlan的 素数与素性测试（Miller-Rabin测试） 讲的非常好，语言也很生动形象，很多本文由于作者懒没有提到的的定义，证明，定理以及有趣的历史都可以在上面找到。 Pollard-Rho算法book丶book丶的 Pollard_rho 因数分解 主要看判环法的代码。Doggu的 大数质因解：浅谈Miller-Rabin和Pollard-Rho算法 以及由Doggu翻译的一篇文章 感觉两篇文章都非常好，很多本人没法证明的或者是解释不清楚的都可以在这两篇文章里找到。努力努力再努力x的 大数因式分解 Pollard_rho 算法详解cz_xuyixuan的 【学习笔记】Pollard’s rho算法 写的比较详细，不过本人理解起来较为困难，提供神奇的优化。Great_Influence的洛谷题解 Pollard-Rho 变成了 Pollard−Pho ：) $46856248255981$好像可以被其他数字判掉？？？学到了。 代码不要打龟速乘，不要打龟速乘，不要打龟速乘打$O(1)$快速乘，亲测龟速乘跑$4s$，快速乘跑$0.5s$。为什么我一个每个数$gcd$一下$Wa$了，优化算法复杂度的时候每$127$个数$gcd$一下，竟然$A$了，优化复杂度怎么优化到正确性上去了？？？卡常卡死我了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;time.h&gt;using namespace std;template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int T;long long ans;const long long MR[]=&#123;2,3,7,61,24251&#125;;//long long mul(long long x,long long y,long long p)//&#123;// long long ans=0;// while(y)// &#123;// if(y&amp;1)ans=(ans+x)%p;// x=(x+x)%p;// y&gt;&gt;=1;// &#125;// return ans;//&#125;inline long long mul(long long x,long long y,long long mod)&#123; long long tmp=(x*y-(long long)((long double)x/mod*y+1.0e-8)*mod); return tmp&lt;0 ? tmp+mod : tmp;&#125;inline long long add(long long x,long long y,long long p)&#123; long long tmp=x+y; if(tmp&gt;p)tmp-=p; return tmp;&#125;inline long long fpow(long long x,long long y,long long p)&#123; long long ans=1; while(y) &#123; if(y&amp;1)ans=mul(ans,x,p); x=mul(x,x,p); y&gt;&gt;=1; &#125; return ans;&#125;long long gcd(long long x,long long y)&#123; return y? gcd(y,x%y):x;&#125;inline bool Miller_Rabin(long long n)&#123; if(n==2||n==3)return true; if(n%2==0||n==1||n==46856248255981)return false; long long d=n-1; int s=0; while(!(d&amp;1))s+=1,d&gt;&gt;=1; for(int i=0;i&lt;5;i++) &#123; if(n==MR[i])return true; if(n%MR[i]==0)return false; long long x=fpow(MR[i],d,n),y=0; for(int j=1;j&lt;=s;j++) &#123; y=mul(x,x,n); if(y==1&amp;&amp;x!=1&amp;&amp;x!=n-1)return false; x=y; &#125; if(y!=1)return false; &#125; return true;&#125;inline long long Irand(long long x)&#123; return 1ll*((rand()&lt;&lt;15^rand())&lt;&lt;30^(rand()&lt;&lt;15^rand()))%x;&#125;inline long long Pollard_Rho(long long n,long long c)&#123; long long x=Irand(n-1)+1; long long y=x,k=2,val=1; for(int i=1;;i++) &#123; x=add(mul(x,x,n),c,n); val=mul(val,add(y-x,n,n),n); if(i%127==0) &#123; long long d=gcd(val,n); if(d!=1&amp;&amp;d!=n)return d; val=1; &#125;// long long d=gcd(add(y-x,n,n),n);// if(d!=1&amp;&amp;d!=n)return d; if(x==y)return n; if(i==k) &#123; long long d=gcd(val,n); if(d!=1&amp;&amp;d!=n)return d; val=1; y=x; k&lt;&lt;=1; &#125; &#125;&#125;void Find(long long n,long long c)&#123; if(n==1||n&lt;=ans)return ; if(Miller_Rabin(n)) &#123; ans=max(n,ans); return ; &#125; long long p=n; while(p&gt;=n)p=Pollard_Rho(p,c--); Find(p,c); Find(n/p,c);&#125;int main()&#123; srand(19491001); T=read&lt;int&gt;(); for(int tot=1;tot&lt;=T;tot++) &#123; long long x=read&lt;long long&gt;(); if(!Miller_Rabin(x)) &#123; ans=0; Find(x,100); printf("%lld\n",ans); &#125; else puts("Prime"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>Miller-Rabin算法</tag>
        <tag>Pollard-Rho算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF321E Ciel and Gondolas / BZOJ5311 贞鱼]]></title>
    <url>%2F2019%2F04%2F30%2FCF321E-Ciel-and-Gondolas-BZOJ5311-%E8%B4%9E%E9%B1%BC%2F</url>
    <content type="text"><![CDATA[CF321E Ciel and Gondolas / BZOJ5311 贞鱼传送门洛谷BZOJ 题意描述众所周知，贞鱼是一种高智商水生动物。不过他们到了陆地上智商会减半。这不？他们遇到了大麻烦！$n$只贞鱼到陆地上乘车，现在有$k$辆汽车可以租用。由于贞鱼们并不能在陆地上自由行走，一辆车只能载一段连续的贞鱼。贞鱼们互相有着深深的怨念，每一对贞鱼之间有怨气值。第$i$只贞鱼与第$j$只贞鱼的怨气值记为$Y _ {i,j}$，且$Y _ {i,j}$=$Y _ {j,i}$，$Y _ {i,i}$=0。每辆车载重不限，但是每一对在同辆车中的贞鱼都会产生怨气值。当然,超级贞鱼zzp长者希望怨气值的总和最小。不过他智商已经减半,想不出分配方案。他现在找到了你,请你帮助他分配贞鱼们,并输出最小怨气值之和$ans$。 输入输出格式输入格式：第一行两个整数:$n$,$k$。接下来读入一个$n$行$n$列的矩阵。矩阵中第$i$行$j$列的元素表示$Y _ {i,j}$。当然这个矩阵是对称的。 输出格式：一个整数$ans$，表示：最小的怨气值之和★注意：同辆车中，贞鱼$i$,$j$之间的怨气只算一次！$1 \le n \le 4000 ，1 \le k \le min(n , 800) , 0 \le Y _ {i,j} \le 10 $ 输入输出样例输入样例#1：8 30 1 1 1 1 1 1 11 0 1 1 1 1 1 11 1 0 1 1 1 1 11 1 1 0 1 1 1 11 1 1 1 0 1 1 11 1 1 1 1 0 1 11 1 1 1 1 1 0 11 1 1 1 1 1 1 0 输出样例#1：7 说明【样例解释1】编号为1，2，3的贞鱼一辆车：怨气值和为3；编号为4，5，6的贞鱼一辆车：怨气值和为3；编号为7，8的贞鱼一辆车：怨气值和为1。最小怨气值总和为 3 + 3 + 1 = 7 。 分析本题也是$WQS$二分的模板题，但困扰本蒟蒻的不是$WQS$二分，而是$DP$，众所周知，本题的状态转移方程式为 f_i=min\left(f_j+\cfrac{sum_{i,i}+sum_{j,j}-sum_{i,j}-sum_{j,i}}{2}\right)(1 \le j < i)其中$f_i$为考虑到第$i$只贞鱼，$sum _ {i,j}$表示矩阵$(1,1),(i,1),(1,j),(i,j)$之和。据说这个式子满足决策单调性。决策单调性是什么？？？就是说如果存在$f_a$比$f_b$小，那么就不可能从$f_a$转移过来。为什么？？？上网找了很多题解，要么不会证，要么强到不想证（菜是原罪）终于…发现一位巨佬——T_Y_P_E。蒟蒻在Ta的博客里找到了证明和做法，以下转自T_Y_P_E的题解。 选择单调性的话，是和dp值的增长率的大小有关的。如果不懂的话，可以看一下下面这个图。首先将式子中的对于i而言的非常数项提出来：-(sum[i][j]+sum[j][i]-sum[j][j])，然后下面的图表现的是括号里面(先令作F(i,j))的几何意义。j1&lt;j2是显然的.其中橙色部分v表示的就是F(i,j2)随i的变化量，而绿色部分就是F(i,j1)随i的变化量。可见delta(F(i,j2))是大于delta(F(i,j1))的，也就是说dp是中和sum[][]有关的那一坨中中，如果j1&lt;j2，因为对于j1和j2而言，sum[i][i]的增加率肯定是相等的，而F(i,j1)增加的要慢一些，也就是它阻碍sum[i][i]增加的作用要小一些，那么对应的j1的总的增加量就要大一些。 因为我们要求的是最小值，而此时如果dp[j1]还大于dp[j2]的话，在i增大的过程中，j1是绝对不可能成为决策点的。于是就可以把j1舍去了。 这里博主可能说的有些复杂，能理解就好。 这样子就可以利用决策单调性把整体时间复杂度优化到O(nlognlogmaxval)了。至于决策单调性的具体过程，大概就是先发现一个决策点对一个连续的区间进行转移，所以可以在队列里面放入一个决策点当前能够更新的左右端点和自己的下标。 首先先默认能够更新到n，然后在之后的插入决策点的过程中，将绝对不可能进行之后的转移的点弹掉，然后在一个完整的区间内部进行二分，将这个区间拆成两个，其中右边的那个就是新插进去的决策点的更新区间啦。 若您认为转载效果不佳，可在下方找到原博客网址。 学习完巨佬的优化后，本题就可以做了。但本蒟蒻还想转一下巨佬的提示。 1.在最后算答案加回多算的代价的时候，记得是每辆车多算的代价乘上k，而不是乘上你这个方案的车的数量2.在DP的转移过程中，除了要将值的大小设为第一比较关键字外，还要将选取车的数量设为第二关键字进行比较。通常是这样的：如果你在外层的二分中是判定当前选取车的数量&lt;= k的时候算答案的话，你在内层就要保证在dp值相同的情况下，尽可能地少使用车；反之亦然（全部反过来就行了）。 真是叫人半懂不懂的。蒟蒻还要思考一下。也许以后会再更新本蒟蒻的理解以及拓展。 参考资料T_Y_P_E的 【Codeforces 321E / BZOJ 5311】【DP凸优化】【单调队列】贞鱼 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 4010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;struct Node&#123; int l; int r; int v;&#125;Q[maxn];int n,m,f[maxn],cnt[maxn],sum[maxn][maxn];int Get(int j,int i)&#123; return f[j]+(sum[i][i]+sum[j][j]-sum[i][j]-sum[j][i])/2;&#125;int cmp(int v1,int v2,int n1,int n2)&#123; if(v1&lt;v2)return 1; if(v1&gt;v2)return -1; if(n1&lt;n2)return 1; if(n1&gt;n2)return -1; return 0;&#125;bool check(int v)&#123; int h=0,t=0; Q[t]=(Node)&#123;1,n,0&#125;; f[0]=0; for(int i=1;i&lt;=n;i++) &#123; while(h&lt;=t&amp;&amp;Q[h].r&lt;i)h+=1; int j=Q[h].v; cnt[i]=cnt[j]+1; f[i]=Get(j,i)+v; while(h&lt;=t&amp;&amp;cmp(Get(Q[t].v,Q[t].l),Get(i,Q[t].l),cnt[Q[t].v],cnt[i])==-1)t-=1; if(h&lt;=t) &#123; int l=Q[t].l,r=Q[t].r; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(cmp(Get(i,mid),Get(Q[t].v,mid),cnt[i],cnt[Q[t].v])==1)r=mid-1; else l=mid+1; &#125; Q[t].r=r; if(l&lt;=n)Q[++t]=(Node)&#123;l,n,i&#125;; &#125; else Q[++t]=(Node)&#123;i,n,i&#125;; &#125; return cnt[n]&lt;=m;&#125;int main()&#123; read(n,m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+read&lt;int&gt;(); int l=0,r=0x7fffffff; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid))r=mid-1; else l=mid+1; &#125; check(l); printf("%d\n",f[n]-l*m); return 0;&#125;]]></content>
      <tags>
        <tag>WQS二分</tag>
        <tag>DP</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4983 忘情]]></title>
    <url>%2F2019%2F04%2F27%2FP4983-%E5%BF%98%E6%83%85%2F</url>
    <content type="text"><![CDATA[P4983 忘情传送门洛谷 题目背景“为什么要离开我！” “因为你没玩儿转！” “我玩儿转了！” “那好，你现在就给我维护这么一个式子！” “为什么要出这么毒瘤的东西。” “为了恶心你。” “……” …………………………….……………………………. 题目描述你的 $npy$ 为了恶心你，特地请了四位大神和一个辣鸡！ $ \rm hdxriehdxrie$ 说：“我们得求和。”于是有了 $\sum \limits_{i=1}^n x_i $。 $\rm ImagineImagine$ 说：“我们得有平均数。”于是有了 $\bar x $。 $\rm TimeTravellerTimeTraveller$ 说：“我们得有加减乘除。”于是有了一些恶心的组合。 $\rm Althen·Way·SatanAlthen⋅Way⋅Satan$ 说：“我们还得有平方。”于是我们将它平方。 最垃圾的 $\rm ZredXNyZredXNy$ 说：“那我帮你们整合一下。” 于是，我们得到了这么一个式子 : \cfrac{\left((\sum\limits_{i=1}^{n}x_i\times \bar x)+\bar x\right)^2}{\bar x^2}我们定义一段序列的值为这个，其中 $n$为此序列的元素个数。 我们给定一段长度为 $n$ 的序列,现在要求将它分成 $m$ 段，要求每一段的值的总和最小，求出这个最小值。 输入输出格式输入格式：第一行两个正整数，分别为 $n$，$m$，定义见题面。 接下来一行为 $n$ 个正整数，依次给出这个序列的每个元素的值 $x_i$ 。 输出格式：一个整数，求出这个最小值。 输入输出样例输入样例#1：3 21 2 3 输出样例#1：32 输入样例#2：10 31 2 3 4 5 6 7 8 9 10 输出样例#2：1140 说明对于 $30 \% $ 的数据，$m \le n \le500$； 另有 $20 \% $ 的数据，保证 $m=2$； 对于 $100 \% $ 的数据，$m \le n \le 100000$，$1 \le x_i \le 1000$。 分析这种题先看看能不能化简式子。 \cfrac{\left((\sum\limits_{i=1}^{n}x_i \times \bar x)+\bar x\right)^2}{\bar x^2} \cfrac{\left(\bar x\sum\limits_{i=1}^{n}x_i + \bar x\right)^2}{\bar x^2} \cfrac{\bar x^2\left(\sum\limits_{i=1}^{n}x_i + 1\right)^2}{\bar x^2} \left(\sum\limits_{i=1}^{n}x_i+1 \right)^2嗯，斜率优化经典题。但有个$m$怎么办？上$WQS$二分。具体的然后考虑如何限制段数。感性地理解或者打表观察或者严格的数学证明可以发现：如果我们给每个$f_i$ 值都强行加上一个$val$，相当于是强行挂了一个重物上去，现在要最小化每个$f_i$ ，那么你挂的东西越重，为了最小化$f_i$而划分的总段数就会越少。 所以我们可以二分这个重物$val$，斜率优化做一遍$dp$，同时记录一下划分段数$cnt_i$，然后判断划分的总段数$cnt_n$与$m$的大小关系。如果$cnt_n&gt;m$就说明$val$不够大，要调大。(做法来自GKxx的题解） 参考资料$WQS$二分Creeper_LKF的 关于WQS二分算法以及其一个细节证明 本题题解GKxx的题解 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 100010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,m,Q[maxn],cnt[maxn];long long s[maxn],f[maxn];double calc(int a,int b)&#123; return (f[b]+s[b]*s[b]-2*s[b]-f[a]-s[a]*s[a]+2*s[a])/(2.*(s[b]-s[a]));&#125;bool check(long long v)&#123; int head=0,tail=0; for(int i=1;i&lt;=n;i++) &#123; while(head&lt;tail&amp;&amp;calc(Q[head],Q[head+1])&lt;=s[i])head+=1; f[i]=f[Q[head]]+(s[i]-s[Q[head]]+1)*(s[i]-s[Q[head]]+1)+v; cnt[i]=cnt[Q[head]]+1; while(head&lt;tail&amp;&amp;calc(Q[tail-1],Q[tail])&gt;=calc(Q[tail],i))tail-=1; Q[++tail]=i; &#125; return cnt[n]&gt;=m;&#125;int main()&#123; read(n,m); for(int i=1;i&lt;=n;i++)s[i]=s[i-1]+read&lt;int&gt;(); long long l=0,r=1e16; while(l&lt;=r) &#123; long long mid=(l+r)&gt;&gt;1; if(check(mid))l=mid+1; else r=mid-1; &#125; check(r); printf("%lld\n",f[n]-m*r); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>WQS二分</tag>
        <tag>DP</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2624 [HNOI2008]明明的烦恼]]></title>
    <url>%2F2019%2F04%2F24%2FP2624-HNOI2008-%E6%98%8E%E6%98%8E%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[P2624 [HNOI2008]明明的烦恼传送门洛谷 题目描述自从明明学了树的结构,就对奇怪的树产生了兴趣…… 给出标号为$1$到$N$的点,以及某些点最终的度数,允许在任意两点间连线,可产生多少棵度数满足要求的树? 输入输出格式输入格式：第一行为$N (0 &lt; N \le 1000)$,接下来$N$行,第$i+1$行给出第i个节点的度数$D_i$,如果对度数不要求,则输入$-1$ 输出格式：一个整数,表示不同的满足要求的树的个数,无解输出$0$ 输入输出样例输入样例#1：31-1-1 输出样例#1：2 说明两棵树分别为1-2-3 ; 1-3-2 分析前置知识：$Prufer$数列。众所周知，对于给定度数的无根树，共有$\cfrac{ (n-2)! }{ \prod_{i=1}^n (d_i-1)! }$情况。使用$Prufer$数列可以很方便的证明。但本题不是这么简单。首先考虑已知的条件，我们记$sum$为已知条件的和，$cnt$为已知条件个数。很显然，只考虑已知度数的点组成的无根树的情况，共有$\cfrac{ sum! }{ \prod_{i=1}^{cnt} (d_i-1)!}$种情况，直接套开头的式子。再考虑在总点数组成的$Prufer$数列中，由我们的已知点组成的$Prufer$子序列有多少种情况，显然，组合知识告诉我们，有$\dbinom{n-2}{sum}$种情况。在考虑剩下的位置，所以要乘上$(n-cnt)^{n-2-sum}$。化简一波： \frac{(n-2)!}{sum!(n-2-sum)!} \times \frac{ sum! }{ \prod_{i=1}^{cnt} (d_i-1)!} \times (n-cnt)^{n-2-sum} \\ \Rightarrow \frac{(n-2)!}{(n-2-sum)!\prod_{i=1}^{cnt} (d_i-1)!} \times (n-cnt)^{n-2-sum}发现一个很尴尬的问题，我们…似乎需要…高精度！！！高精乘还好说，高精除就比较尴尬了。弃疗其实还有一个办法，质因数分解。对于$n!$，如果$p$是一个质数，那么它的次数为 \left \lfloor \frac{n}{p^1} \right \rfloor + ... + \left \lfloor \frac{n}{p^x} \right \rfloor (p^x \le n)所以高精除就搞定了。至于高精乘，打板子。 参考资料$Prufer$数列自为风月马前卒的 prufer序列笔记xun的 prufer数列 本题题解本校巨佬autoint的题解TheLostWeak的题解JMJST的题解怡红公子的题解 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1010#define mod (int)1e6template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,cnt,sum,len=1,d[maxn],p[maxn],num[maxn],ans[maxn]=&#123;1&#125;;void init()&#123; for(int i=2;i&lt;=n;i++) &#123; if(!p[i])p[++p[0]]=i; for(int j=1;j&lt;=p[0]&amp;&amp;p[j]*i&lt;=n;j++) &#123; p[p[j]*i]=true; if(i%p[j]==0)break; &#125; &#125;&#125;void decomp(int n,int f)&#123; for(int i=1;i&lt;=p[0]&amp;&amp;p[i]&lt;=n;i++) for(int j=n;j&gt;=p[i];j/=p[i]) num[i]+=j/p[i]*f;&#125;void mul(int n)&#123; for(int i=0;i&lt;len;i++)ans[i]*=n; for(int i=0;i&lt;len;i++) if(ans[i]&gt;=mod) ans[i+1]+=ans[i]/mod,ans[i]%=mod; if(ans[len])len+=1;&#125;int main()&#123; n=read&lt;int&gt;(); init(); for(int i=1;i&lt;=n;i++) &#123; int tmp=read&lt;int&gt;(); if(tmp==-1)continue; cnt+=1; if(tmp&lt;=0||tmp&gt;n-2) &#123; puts("0"); return 0; &#125; sum+=tmp-1; d[++d[0]]=tmp; &#125; if(d[0]&gt;n-2) &#123; puts("0"); return 0; &#125; decomp(n-2,1); decomp(n-2-sum,-1); for(int i=1;i&lt;=d[0];i++)decomp(d[i]-1,-1); for(int i=1;i&lt;=p[0];i++) while(num[i]--) mul(p[i]); for(int i=1;i&lt;=n-2-sum;i++)mul(n-cnt); printf("%d",ans[len-1]); for(int i=len-2;i&gt;=0;i--)printf("%06d",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>高精度</tag>
        <tag>Prufer数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SP8093 JZPGYZ - Sevenk Love Oimaster]]></title>
    <url>%2F2019%2F04%2F24%2FSP8093-JZPGYZ-Sevenk-Love-Oimaster%2F</url>
    <content type="text"><![CDATA[SP8093 JZPGYZ - Sevenk Love Oimaster传送门洛谷 题意描述Oimaster and sevenk love each other.But recently,sevenk heard that a girl named ChuYuXun was dating with oimaster.As a woman’s nature, sevenk felt angry and began to check oimaster’s online talk with ChuYuXun. Oimaster talked with ChuYuXun n times, and each online talk actually is a string.Sevenk asks q questions like this, “how many strings in oimaster’s online talk contain this string as their substrings?题目大意：给定n个模板串，以及m个查询串，依次查询每一个查询串是多少个模板串的子串 输入输出格式输入格式：There are two integers in the first line, the number of strings n and the number of questions q. And n lines follow, each of them is a string describing oimaster’s online talk. And q lines follow, each of them is a question.n&lt;=10000, q&lt;=60000 the total length of n strings&lt;=100000, the total length of q question strings&lt;=360000 输出格式：For each question, output the answer in one line. 输入输出样例输入样例#1：3 3abcabcabcaaaaafeabcaca 输出样例#1：131 说明【样例解释1】$abc$在$abcabcabc$中出现了，所以第一个询问答案为1。 $a$在三个字符串中都出现了，所以第二个询问答案为3。 $ca$只在$abcabcabc$中出现了，所以第三个询问的答案为1。 分析这是一道广义$SAM$模板题。本来想打一打来练手，但似乎出了锅。具体的说：我打了一份枚举子串更新$SAM$的代码，过了。忽然想起，似乎还可以在插入时更新$SAM$，打了以后，挂了。不知道是根本不能这样做还是我哪里打挂了，请大佬帮忙查一下错，谢谢！ 代码插入时更新$SAM$然后挂了的代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 100010#define maxm 360010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,m,las,cnt=1,fa[maxn&lt;&lt;1],vis[maxn&lt;&lt;1],len[maxn&lt;&lt;1],val[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26];char str[maxm];void add(int cc,int pos)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][cc];p=fa[p])ch[p][cc]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][cc]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; len[nq]=len[p]+1; fa[nq]=fa[q]; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][cc]==q;p=fa[p])ch[p][cc]=nq; &#125; &#125; for(;np&amp;&amp;vis[np]!=pos;np=fa[np]) vis[np]=pos,val[np]+=1;&#125;int main()&#123; read(n,m); for(int i=1;i&lt;=n;i++) &#123; las=1; scanf("%s",str); int len=strlen(str); for(int j=0;j&lt;len;j++) add(str[j]-'a',i); &#125; for(int i=1;i&lt;=m;i++) &#123; int now=1,flag=true; scanf("%s",str); int len=strlen(str); for(int j=0;j&lt;len;j++) &#123; if(!ch[now][str[j]-'a']) &#123; flag=false; puts("0"); break; &#125; now=ch[now][str[j]-'a']; &#125; if(flag)printf("%d\n",val[now]); &#125; return 0;&#125; 枚举子串更新的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 100010#define maxm 10010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,m,las,cnt=1,fa[maxn&lt;&lt;1],vis[maxn&lt;&lt;1],len[maxn&lt;&lt;1],val[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26];string str[maxm];void add(int cc)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][cc];p=fa[p])ch[p][cc]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][cc]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; len[nq]=len[p]+1; fa[nq]=fa[q]; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][cc]==q;p=fa[p])ch[p][cc]=nq; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; las=1; cin&gt;&gt;str[i]; for(int j=0;j&lt;(int)str[i].length();j++) add(str[i][j]-'a'); &#125; for(int i=1;i&lt;=n;i++) &#123; int now=1; for(int j=0;j&lt;(int)str[i].length();j++) &#123; now=ch[now][str[i][j]-'a']; int tmp=now; while(tmp&amp;&amp;vis[tmp]!=i) &#123; vis[tmp]=i; val[tmp]+=1; tmp=fa[tmp]; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; int now=1,flag=true; cin&gt;&gt;str[0]; for(int j=0;j&lt;(int)str[0].length();j++) &#123; if(!ch[now][str[0][j]-'a']) &#123; flag=false; puts("0"); break; &#125; now=ch[now][str[0][j]-'a']; &#125; if(flag)printf("%d\n",val[now]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-4-24课件]]></title>
    <url>%2F2019%2F04%2F23%2F2019-4-24%E8%AF%BE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>课件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3277 串]]></title>
    <url>%2F2019%2F04%2F23%2FBZOJ3277-%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[BZOJ3277 串传送门BZOJ 题目描述字符串是oi界常考的问题。现在给定你$n$个字符串，询问每个字符串有多少子串（不包括空串）是所有$n$个字符串中至少$k$个字符串的子串（注意包括本身）。 输入输出格式输入格式：第一行两个整数$n$，$k$。接下来$n$行每行一个字符串。$n,k,l \le 100000$ 输出格式：输出一行$n$个整数，第$i$个整数表示第$i$个字符串的答案。 输入输出样例输入样例：3 1abcaab 输出样例：6 1 3 分析广义$SAM$模板题(应该是)。不知道为什么，用了快读读数字，再用cin读string就爆炸了。 参考资料广义$SAM$dwjshift的 用SAM建广义后缀树 提供在线和离线建法。话说这篇资料里提到的不在Trie上建$SAM$是怎么做的？？？wangzhen_yu的 广义后缀自动机 提供很好的例题及代码讲解。以前不懂什么叫进行内容更新，菜啊phile的 关于广义后缀树（多串SAM）的总结 本题自为风月马前卒的题解 主要参考题解，这篇题解是枚举前缀的后缀(即子串)进行内容更新，而不是插入时更新，换句话说，这篇题解是从上至下更新，而不是一般的插入时从下至上更新。clover_hxy的 题解 这篇题解是在建自动机的时候统计的每个状态的出现次数，最后求答案时连边跳，不过没看懂其中的mark数组是干什么的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 100010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,m,las,cnt=1,times[maxn&lt;&lt;1],sum[maxn&lt;&lt;1],vis[maxn&lt;&lt;1],len[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26];string str[maxn];void add(int cc)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][cc];p=fa[p])ch[p][cc]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][cc]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; fa[nq]=fa[q]; len[nq]=len[p]+1; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][cc]==q;p=fa[p])ch[p][cc]=nq; &#125; &#125;&#125;void dfs(int x)&#123; if(!x||vis[x])return ; vis[x]=true; dfs(fa[x]); sum[x]+=sum[fa[x]];&#125;void GetTimes()&#123; for(int i=1;i&lt;=n;i++) &#123; int now=1; for(int j=0;j&lt;(int)str[i].length();j++) &#123; now=ch[now][str[i][j]-'a']; int tmp=now; while(tmp&amp;&amp;vis[tmp]!=i) &#123; vis[tmp]=i; times[tmp]+=1; tmp=fa[tmp]; &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; las=1; cin&gt;&gt;str[i]; for(int j=0;j&lt;(int)str[i].length();j++)add(str[i][j]-'a'); &#125; GetTimes(); for(int i=1;i&lt;=cnt;i++)sum[i]=(times[i]&gt;=m)*(len[i]-len[fa[i]]); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=cnt;i++)dfs(i); for(int i=1;i&lt;=n;i++) &#123; int ans=0,now=1; for(int j=0;j&lt;(int)str[i].length();j++) now=ch[now][str[i][j]-'a'],ans+=sum[now]; printf("%d ",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4022 [CTSC2012]熟悉的文章]]></title>
    <url>%2F2019%2F04%2F21%2FP4022-CTSC2012-%E7%86%9F%E6%82%89%E7%9A%84%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[P4022 [CTSC2012]熟悉的文章传送门洛谷 题目描述阿米巴是小强的好朋友。 在小强眼中，阿米巴是一个作文成绩很高的文艺青年。为了获取考试作文的真谛，小强向阿米巴求教。阿米巴给小强展示了几篇作文，小强觉得这些文章怎么看怎么觉得熟悉，仿佛是某些范文拼拼凑凑而成的。小强不禁向阿米巴投去了疑惑的眼光，却发现阿米巴露出了一个狡黠的微笑。 为了有说服力地向阿米巴展示阿米巴的作文是多么让人觉得“眼熟”，小强想出了一个评定作文 “熟悉程度”的量化指标：L 0 .小强首先将作文转化成一个 01 串。之后，小强搜集了各路名家的文章，同样分别转化成 01 串后，整理出一个包含了 M 个 01 串的“ 标准作文库 ”。 小强认为：如果一个 01 串长度不少于 L 且在 标准作文库 中的某个串里出现过（即，它是 标准作文库 的 某个串 的一个 连续子串 ），那么它是“ 熟悉 ”的。对于一篇作文（一个 01 串）A，如果能够把 A 分割成若干段子串，其中“ 熟悉 ” 的子串的 长度 总 和 不少于 A 总 长度的 90%，那么称 A 是 “ 熟悉的文章 ”。 L 0 是 能够让 A 成为 “ 熟悉的文章 ” 的 所有 L 的最大值 （如果不存在这样的 L，那么规定 L 0 =0）。 举个例子： 小强的作文库里包含了如下 2 个字符串： 10110000001110有一篇待考察的作文是： 1011001100小强计算出这篇作文 L 的最大值是 4，因为待考察的作文可以视作’10110’+’0110’+’0’，其中’10110’和’0110’被判定为 “ 熟悉 ” 的。而当 L = 5 或是更大的时候，不存在符合题意的分割方法。所以，这篇作文的 L 0 = 4。小强认为阿米巴作文的 L 0 值比其他同学的明显要大。请你帮他验证一下。 输入输出格式输入格式：输入文件 cheat.in 第一行是两个整数 N, M，表示待检查的作文数量，和小强的标准作文库的行数。 接下来是 M 行的 01 串，表示标准作文库。 接下来是 N 行的 01 串，表示 N 篇作文。 输出格式：输出文件 cheat.out 包含 N 行，每一行包含一个整数，表示该篇作文的 L 0 值。 输入输出样例输入样例#1：1 2101100000011101011001100 输出样例#1：4 说明对于 30%的测试数据，输入文件的长度不超过 1000 字节。 对于 50%的测试数据，输入文件的长度不超过 61000 字节。 对于 80%的测试数据，输入文件的长度不超过 250000 字节。 对于 100%的测试数据，输入文件的长度不超过 1100000 字节。 分析$0pts：$不打或打炸。看到求最小的最大值，想到二分。证明一波：很明显，对于大的可行的串，它的小的子串一定也可行(即，对于一个可行的L,小于它的L一定也可行)，反之不一定成立，满足单调性，所以可以二分。那么怎么$check$呢？？？想到DP。我们设$f_i$表示以$i$位置结尾时题意要求的最大值。很容易写出转移方程如下： f_j=max(f_i-1,f_j+i-(j+1)+1),j \in [i-len_i,i-L]其中，$len_i$表示符合题意要求的分割的最大值，即以$i$结尾的可以被匹配的01串的最大值。直接搞，$60pts$到手。但转念想想，正解(如果也是用这个DP方程的话)不可能直接暴力转移，不然就满分了，不会才$60pts$。如果想要通过本题的话，复杂度应该是在$O(nlogn)$左右。那么转移应该做到$O(1)$才行。想想把$O(n)$的DP转移优化为$O(1)$的方法就那么几种。再发现两个边界($i-len_i$,$i-L$)中第一个边界肯定是单调不降的，第二个边界是单调上升的，很容易理解和证明，这里省去证明。于是想到单调队列优化DP。稍微化一下式子就行了。DP处理完了。想一想$len_i$怎么求，发现这个东西在广义$SAM$上跑一下就行了。另外，在打代码的时候注意一下循环语句的执行顺序，我就在把while改for的时候爆炸了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1000010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,m,sl,cnt=1,las,Q[maxn],f[maxn],match[maxn],len[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][2];char str[maxn];void add(int cc)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][cc];p=fa[p])ch[p][cc]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][cc]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; len[nq]=len[p]+1; fa[nq]=fa[q]; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][cc]==q;p=fa[p])ch[p][cc]=nq; &#125; &#125;&#125;void Match()&#123; int p=1,l=0,c; for(int i=1;i&lt;=sl;i++) &#123; c=str[i]-'0'; if(ch[p][c])p=ch[p][c],l+=1; else &#123; for(;p&amp;&amp;!ch[p][c];p=fa[p]); if(p)l=len[p]+1,p=ch[p][c]; else p=1,l=0; &#125; match[i]=l; &#125;&#125;bool check(int L)&#123; int h=1,t=0; for(int i=1;i&lt;=L-1;i++)f[i]=0; for(int i=L;i&lt;=sl;i++) &#123; f[i]=f[i-1]; while(h&lt;=t&amp;&amp;f[Q[t]]-Q[t]&lt;f[i-L]-(i-L))t-=1; Q[++t]=i-L; while(h&lt;=t&amp;&amp;Q[h]&lt;i-match[i])h+=1; if(h&lt;=t)f[i]=max(f[i],f[Q[h]]+i-Q[h]); &#125; return f[sl]*10&gt;=sl*9;&#125;int main()&#123; read(n,m); for(int i=1;i&lt;=m;i++) &#123; las=1; scanf("%s",str+1); sl=strlen(str+1); for(int j=1;j&lt;=sl;j++)add(str[j]-'0'); &#125; for(int tot=1;tot&lt;=n;tot++) &#123; scanf("%s",str+1); sl=strlen(str+1); Match(); int l=0,r=sl,ans=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid))ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>CTSC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3649 [APIO2014]回文串]]></title>
    <url>%2F2019%2F04%2F21%2FP3649-APIO2014-%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[P3649 [APIO2014]回文串传送门洛谷 题目描述给你一个由小写拉丁字母组成的字符串 $s$。我们定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。 对于给你的这个字符串 $s$，求所有回文子串中的最大存在值。 输入输出格式输入格式：一行，一个由小写拉丁字母（a~z）组成的非空字符串 $s$。 输出格式：输出一个整数，表示所有回文子串中的最大存在值。 输入输出样例输入样例#1：abacaba 输出样例#1：7 输入样例#2：www 输出样例#2：4 说明【样例解释1】用 $\lvert s \rvert$ 表示字符串 s 的长度。 一个字符串 $s_1 s_2 \dots s_{\lvert s \rvert}$的子串是一个非空字符串 $s_i s_{i+1} \dots s_j$，其中 $1 \leq i \leq j \leq \lvert s \rvert$。每个字符串都是自己的子串。 一个字符串被称作回文串当且仅当这个字符串从左往右读和从右往左读都是相同的。 这个样例中，有 $7$ 个回文子串 a，b，c，aba，aca，bacab，abacaba。他们的存在值分别为 $4, 2, 1, 6, 3, 5, 7$。 所以回文子串中最大的存在值为 $7$。 第一个子任务共 8 分，满足 $1 \leq \lvert s \rvert \leq 100$。 第二个子任务共 15 分，满足 $1 \leq \lvert s \rvert \leq 1000$。 第三个子任务共 24 分，满足 $1 \leq \lvert s \rvert \leq 10000$。 第四个子任务共 26 分，满足 $1 \leq \lvert s \rvert \leq 100000$。 第五个子任务共 27 分，满足 $1 \leq \lvert s \rvert \leq 300000$。 分析看到“定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度“,第一反应这不是P3804的定义吗。于是…嗯…$SAM$！！！其实是因为我是搜$SAM$的标签搜到的这题嗯…打一发…哦~过了样例。开心ing…交一发….等等！开不开long long。算一波极限,赋值一下,编译器告诉我—-overflow in implicit constant conversion。哦~看来要开long long。交一发….额~50分？？？为什么只有50分？？？我的$SAM$打错了？？？懵逼ing…哦~回文串嘛。为什么直接求所有子串的存在值有50分？？？可是回文串怎么做？？？题解….$SAM$套$Manacher$加倍增？？？好麻烦不打，复杂度还是$O(nlogn)$的，还被卡空间….嗯~纯$SAM$的，可是…图呢？？？没图我怎么知道你在说什么？？？网上一搜…又搜到一篇…还是没图(确切的说，是当时没图)…放弃…颓废ing…算了，回文自动机正等着我…学习ing…发现我的回文自动机没初始化特殊字符？？？(即$s_0=-1$)，还是过了？？？算了，不再交了，放代码的时候加上算了。 参考资料纯$SAM$Leaves的题解asuldb的题解 回文自动机大奕哥&amp;VANE的 Palindromic Tree 回文自动机-回文树 例题+讲解 主要学习资料Clove_unique的 Manacher 回文自动机 学习笔记 主要是为了看图冯钰恒的 回文树/回文自动机/PAM总结——题解 P3649 【[APIO2014]回文串】 主要参考代码实现F.W.Nietzsche的 回文树或者回文自动机，及相关例题KSKUN的 回文自动机原理与实现 Updateasuldb的题解刷新一波又有图了，于是再学…为什么我做的时候你没图，做完就有图了！！！ 代码第一份傻逼的错误代码写了这么久好歹还是放一下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 300010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,las=1,cnt=1,ton[maxn&lt;&lt;1],ns[maxn&lt;&lt;1],len[maxn&lt;&lt;1],siz[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26];long long ans;char str[maxn];void add(int c)&#123; int p=las,np=las=++cnt; siz[np]=1; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][c];p=fa[p])ch[p][c]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; fa[nq]=fa[q]; len[nq]=len[p]+1; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][c]==q;p=fa[p])ch[p][c]=nq; &#125; &#125;&#125;int main()&#123; scanf("%s",str);n=strlen(str); for(int i=0;i&lt;n;i++)add(str[i]-'a'); for(int i=1;i&lt;=cnt;i++)ton[len[i]]+=1; for(int i=1;i&lt;=cnt;i++)ton[i]+=ton[i-1]; for(int i=1;i&lt;=cnt;i++)ns[ton[len[i]]--]=i; for(int i=cnt;i&gt;=1;i--) &#123; siz[fa[ns[i]]]+=siz[ns[i]]; ans=max(ans,1ll*len[ns[i]]*siz[ns[i]]); &#125; printf("%lld\n",ans); return 0;&#125; 回文自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define maxn 300010using namespace std;template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,cnt,last,pos,s[maxn],fail[maxn],len[maxn],Count[maxn],ch[maxn][26];long long ans;char str[maxn];void Init()&#123; len[0]=0; len[1]=-1; fail[0]=1; s[0]=-1; //之前交的时候没加这个，现在补上 cnt=1; last=0;&#125;int Get(int k)&#123; while(s[pos]!=s[pos-len[k]-1])k=fail[k]; return k;&#125;void add(int cc)&#123; s[++pos]=cc; int x=Get(last); if(!ch[x][cc]) &#123; int y=++cnt; len[y]=len[x]+2; fail[y]=ch[Get(fail[x])][cc]; ch[x][cc]=y; &#125; last=ch[x][cc]; Count[last]+=1;&#125;int main()&#123; scanf("%s",str); n=strlen(str); Init(); for(int i=0;i&lt;n;i++)add(str[i]-'a'); for(int i=cnt;i&gt;1;i--) &#123; Count[fail[i]]+=Count[i]; ans=max(ans,1ll*Count[i]*len[i]); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>APIO</tag>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3975 [TJOI2015]弦论]]></title>
    <url>%2F2019%2F04%2F18%2FP3975-TJOI2015-%E5%BC%A6%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[P3975 [TJOI2015]弦论传送门洛谷 题目描述为了提高智商,ZJY开始学习弦论。这一天,她在《 String theory》中看到了这样一道问题:对于一个给定的长度为n的字符串,求出它的第k小子串是什么。你能帮帮她吗? 输入输出格式输入格式：第一行是一个仅由小写英文字母构成的字符串s 第二行为两个整数t和k,t为0则表示不同位置的相同子串算作一个,t为1则表示不同位置的相同子串算作多个。k的意义见题目描述。 输出格式：输出数据仅有一行,该行有一个字符串,为第k小的子串。若子串数目不足k个,则输出-1。 输入输出样例输入样例#1：aabc0 3 输出样例#1：aab 输入样例#2：aabc1 3 输出样例#2：aa 输入样例#3：aabc1 11 输出样例#3：-1 说明数据范围对于$10\%$的数据，$n \le 1000$。 对于$50\%$的数据，$t = 0$。 对于$100\%$的数据，$n \le 5 × 10^5, t &lt; 2, k \le 10^9$。 分析T=0时，设$siz_i=1$，即出现次数设为1。T=1时，将$siz_i$设为$Endpos$的大小，即出现次数。 之前在想如果复制的点不设置$siz_i$，最终统计时是否会出现$siz_i=0$的情况。网上说不会。那就自己yy一下。因为复制的点一定有子树，而$siz_i$是子树中终止节点的个数。那么我们就需要就证明子树中一定有至少一个终止节点。因为它有子树，说明有终止节点(感觉像没证一样，但换个角度想想，我们又不傻，如果它的子树内没有终止节点，那么我们还建子树干嘛，只会平白浪费时间和空间)。所以得证。正确性不保证，自己什么都不懂，没有理论支持，自己yy自然没法保证正确性…如果有人发现这个假了，或者有正确性保证的证明，请评论告诉我，谢谢。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 500010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int T,k,las=1,cnt=1,siz[maxn&lt;&lt;1],sum[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26],len[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],tong[maxn&lt;&lt;1],ns[maxn&lt;&lt;1];char str[maxn];void add(int c)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; siz[cnt]=1; while(p&amp;&amp;!ch[p][c])ch[p][c]=np,p=fa[p]; if(!p)fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[nq]=fa[q]; len[nq]=len[p]+1; fa[q]=fa[np]=nq; while(p&amp;&amp;ch[p][c]==q)ch[p][c]=nq,p=fa[p]; &#125; &#125;&#125;void pre()&#123; for(int i=1;i&lt;=cnt;i++)tong[len[i]]++; for(int i=1;i&lt;=cnt;i++)tong[i]+=tong[i-1]; for(int i=1;i&lt;=cnt;i++)ns[tong[len[i]]--]=i; for(int i=cnt;i&gt;=1;i--) if(T)siz[fa[ns[i]]]+=siz[ns[i]]; else siz[i]=1; siz[1]=0; for(int i=cnt;i&gt;=1;i--) &#123; sum[ns[i]]=siz[ns[i]]; for(int j=0;j&lt;26;j++) if(ch[ns[i]][j]) sum[ns[i]]+=sum[ch[ns[i]][j]]; &#125;&#125;void solve()&#123; if(k&gt;sum[1]) &#123; puts("-1"); return ; &#125; int now=1; k-=siz[now]; while(k) &#123; int i=0; while(k&gt;sum[ch[now][i]]) k-=sum[ch[now][i]],i+=1; now=ch[now][i]; putchar('a'+i); k-=siz[now]; &#125;&#125;int main()&#123; scanf("%s",str); read(T,k); int len=strlen(str); for(int i=0;i&lt;len;i++)add(str[i]-'a'); pre(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3804 后缀自动机]]></title>
    <url>%2F2019%2F04%2F17%2FP3804-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[P3804 后缀自动机传送门洛谷 题目描述给定一个只包含小写字母的字符串$S$, 请你求出 $S$ 的所有出现次数不为 1 的子串的出现次数乘上该子串长度的最大值。 输入输出格式输入格式：一行一个仅包含小写字母的字符串$S$ 输出格式：一个整数，为 所求答案 输入输出样例输入样例#1：abab 输出样例#1：4 说明对于$10\%$的数据，$\lvert S \rvert \le 1000$对于$100\%$的数据，$\lvert S \rvert \le 10^6$ 分析既然是后缀自动机模板，自然用后缀自动机来做，具体的，就是建立后缀自动机，然后再Parent树上DFS，答案为子树大小*节点的len长度的最大值。 Update：以前没能弄清为什么siz[…]=1写在建后缀自动机里就行，写在DFS里就挂，后来Achen告诉我有些点没有siz值。 后缀自动机入门 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1000010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;struct Node&#123; int fa; int len; int ch[30];&#125;node[maxn&lt;&lt;1];struct Edge&#123; int v; Edge *next; Edge(int a=0,Edge *b=NULL) &#123; v=a; next=b; &#125;&#125;*head[maxn&lt;&lt;1];int len,tot=1,las=1;long long ans,siz[maxn&lt;&lt;1];char str[maxn];void add(int c)&#123; int p=las,np=las=++tot; siz[tot]=1; node[np].len=node[p].len+1; for(;p&amp;&amp;!node[p].ch[c];p=node[p].fa)node[p].ch[c]=np; if(!p)node[np].fa=1; else &#123; int q=node[p].ch[c]; if(node[q].len==node[p].len+1)node[np].fa=q; else &#123; int nq=++tot; node[nq]=node[q]; node[nq].len=node[p].len+1; node[q].fa=node[np].fa=nq; for(;p&amp;&amp;node[p].ch[c]==q;p=node[p].fa)node[p].ch[c]=nq; &#125; &#125;&#125;void dfs(int k)&#123; for(Edge *i=head[k];i!=NULL;i=i-&gt;next) &#123; dfs(i-&gt;v); siz[k]+=siz[i-&gt;v]; &#125; if(siz[k]!=1)ans=max(ans,siz[k]*node[k].len);&#125;int main()&#123; scanf("%s",str); len=strlen(str); for(int i=0;i&lt;len;i++)add(str[i]-'a'); for(int i=2;i&lt;=tot;i++)head[node[i].fa]=new Edge(i,head[node[i].fa]); dfs(1); printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>模板</tag>
      </tags>
  </entry>
</search>
