<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[P3975 [TJOI2015]弦论]]></title>
    <url>%2F2019%2F04%2F18%2FP3975-TJOI2015-%E5%BC%A6%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[P3975 [TJOI2015]弦论传送门洛谷 题目描述为了提高智商,ZJY开始学习弦论。这一天,她在《 String theory》中看到了这样一道问题:对于一个给定的长度为n的字符串,求出它的第k小子串是什么。你能帮帮她吗? 输入输出格式输入格式：第一行是一个仅由小写英文字母构成的字符串s 第二行为两个整数t和k,t为0则表示不同位置的相同子串算作一个,t为1则表示不同位置的相同子串算作多个。k的意义见题目描述。 输出格式：输出数据仅有一行,该行有一个字符串,为第k小的子串。若子串数目不足k个,则输出-1。 输入输出样例输入样例#1：aabc0 3 输出样例#1：aab 输入样例#2：aabc1 3 输出样例#2：aa 输入样例#3：aabc1 11 输出样例#3：-1 说明数据范围对于$10\%$的数据，$n \le 1000$。 对于$50\%$的数据，$t = 0$。 对于$100\%$的数据，$n \le 5 × 10^5, t &lt; 2, k \le 10^9$。 分析T=0时，设$siz_i=1$，即出现次数设为1。T=1时，将$siz_1$设为$Endpos$的大小，即出现次数。 之前在想如果复制的点不设置$siz_i$，最终统计时是否会出现$siz_i=0$的情况。网上说不会。那就自己yy一下。因为复制的点一定有子树，而$siz_i$是子树中终止节点的个数。那么我们就需要就证明子树中一定有至少一个终止节点。因为它有子树，说明有终止节点(感觉像没证一样，但换个角度想想，我们又不傻，如果它的子树内没有终止节点，那么我们还建子树干嘛，只会平白浪费时间和空间)。所以得证。正确性不保证，自己什么都不懂，没有理论支持，自己yy自然没法保证正确性…如果有人发现这个假了，或者有正确性保证的证明，请评论告诉我，谢谢。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 500010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int T,k,las=1,cnt=1,siz[maxn&lt;&lt;1],sum[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26],len[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],tong[maxn&lt;&lt;1],ns[maxn&lt;&lt;1];char str[maxn];void add(int c)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; siz[cnt]=1; while(p&amp;&amp;!ch[p][c])ch[p][c]=np,p=fa[p]; if(!p)fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[nq]=fa[q]; len[nq]=len[p]+1; fa[q]=fa[np]=nq; while(p&amp;&amp;ch[p][c]==q)ch[p][c]=nq,p=fa[p]; &#125; &#125;&#125;void pre()&#123; for(int i=1;i&lt;=cnt;i++)tong[len[i]]++; for(int i=1;i&lt;=cnt;i++)tong[i]+=tong[i-1]; for(int i=1;i&lt;=cnt;i++)ns[tong[len[i]]--]=i; for(int i=cnt;i&gt;=1;i--) if(T)siz[fa[ns[i]]]+=siz[ns[i]]; else siz[i]=1; siz[1]=0; for(int i=cnt;i&gt;=1;i--) &#123; sum[ns[i]]=siz[ns[i]]; for(int j=0;j&lt;26;j++) if(ch[ns[i]][j]) sum[ns[i]]+=sum[ch[ns[i]][j]]; &#125;&#125;void solve()&#123; if(k&gt;sum[1]) &#123; puts("-1"); return ; &#125; int now=1; k-=siz[now]; while(k) &#123; int i=0; while(k&gt;sum[ch[now][i]]) k-=sum[ch[now][i]],i+=1; now=ch[now][i]; putchar('a'+i); k-=siz[now]; &#125;&#125;int main()&#123; scanf("%s",str); read(T,k); int len=strlen(str); for(int i=0;i&lt;len;i++)add(str[i]-'a'); pre(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3804 后缀自动机]]></title>
    <url>%2F2019%2F04%2F17%2FP3804-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[P3804 后缀自动机传送门洛谷 题目描述给定一个只包含小写字母的字符串$S$, 请你求出 $S$ 的所有出现次数不为 1 的子串的出现次数乘上该子串长度的最大值。 输入输出格式输入格式：一行一个仅包含小写字母的字符串$S$ 输出格式：一个整数，为 所求答案 输入输出样例输入样例#1：abab 输出样例#1：4 说明对于$10\%$的数据，$|S| \le 1000$对于$100\%$的数据，$|S| \le 10^6$ 分析&nbsp;既然是后缀自动机模板，自然用后缀自动机来做，具体的，就是建立后缀自动机，然后再Parent树上DFS，答案为子树大小*节点的len长度的最大值。 &nbsp;没能弄清为什么siz[…]=1写在建后缀自动机里就行，写在DFS里就挂？？？ Achen告诉我有些点没有siz值。 &nbsp;后缀自动机入门 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1000010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;struct Node&#123; int fa; int len; int ch[30];&#125;node[maxn&lt;&lt;1];struct Edge&#123; int v; Edge *next; Edge(int a=0,Edge *b=NULL) &#123; v=a; next=b; &#125;&#125;*head[maxn&lt;&lt;1];int len,tot=1,las=1;long long ans,siz[maxn&lt;&lt;1];char str[maxn];void add(int c)&#123; int p=las,np=las=++tot; siz[tot]=1; node[np].len=node[p].len+1; for(;p&amp;&amp;!node[p].ch[c];p=node[p].fa)node[p].ch[c]=np; if(!p)node[np].fa=1; else &#123; int q=node[p].ch[c]; if(node[q].len==node[p].len+1)node[np].fa=q; else &#123; int nq=++tot; node[nq]=node[q]; node[nq].len=node[p].len+1; node[q].fa=node[np].fa=nq; for(;p&amp;&amp;node[p].ch[c]==q;p=node[p].fa)node[p].ch[c]=nq; &#125; &#125;&#125;void dfs(int k)&#123; for(Edge *i=head[k];i!=NULL;i=i-&gt;next) &#123; dfs(i-&gt;v); siz[k]+=siz[i-&gt;v]; &#125; if(siz[k]!=1)ans=max(ans,siz[k]*node[k].len);&#125;int main()&#123; scanf("%s",str); len=strlen(str); for(int i=0;i&lt;len;i++)add(str[i]-'a'); for(int i=2;i&lt;=tot;i++)head[node[i].fa]=new Edge(i,head[node[i].fa]); dfs(1); printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
</search>
