<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[P1587 [NOI2016]循环之美]]></title>
    <url>%2F2019%2F09%2F05%2FP1587-NOI2016-%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E%2F</url>
    <content type="text"><![CDATA[P1587 [NOI2016]循环之美传送门洛谷 题目描述牛牛是一个热爱算法设计的高中生。在他设计的算法中，常常会使用带小数的数进行计算。牛牛认为，如果在 $k$ 进制下，一个数的小数部分是纯循环的，那么它就是美的。现在，牛牛想知道：对于已知的十进制数 $n$ 和 $m$，在 $k$ 进制下，有多少个数值上互不相等的纯循环小数，可以用分数 $\frac xy$ 表示,其中 $1≤x≤n,1≤y≤m$，且 $x,y$是整数。一个数是纯循环的，当且仅当其可以写成以下形式：$a.\dot{c_1} c_2 c_3 \dots c_{p - 1} \dot{c_p}$其中，$a$ 是一个整数，$p≥1$；对于 $1≤i≤p$，$c_i$ 是 $k$ 进制下的一位数字。例如，在十进制下，$0.45454545……=0.\dot {4} \dot {5}$是纯循环的，它可以用 $\frac {5}{11}$、$\frac{10}{22}$ 等分数表示；在十进制下，$0.1666666……=0.1\dot6$则不是纯循环的，它可以用 $1/6$ 等分数表示。需要特别注意的是，我们认为一个整数是纯循环的，因为它的小数部分可以表示成 $0$ 的循环或是 $k-1$ 的循环；而一个小数部分非 $0$ 的有限小数不是纯循环的。 输入输出格式输入格式只有一行，包含三个十进制数N,M,K意义如题所述,保证 $1 \le n \le 10^9,1 \le m \le 10^9,2 \le k \le2000$ 输出格式一行一个整数，表示满足条件的美的数的个数。 输入输出样例输入样例#1：2 6 10 输出样例#1：4 说明/提示满足条件的数分别是： $\frac{1}{1}=1.0000……$$\frac{1}{3}=0.3333……$$\frac{2}{1}=2.0000……$$\frac{2}{3}=0.6666……$ $\frac{1}{1}$ 和 $\frac{2}{2}$ 虽然都是纯循环小数，但因为它们相等，因此只计数一次；同样，$\frac{1}{3}$ 和 $\frac{2}{6}$ 也只计数一次。 对于所有的测试点，保证 $1 \le n \le 10^9, 1 \le m \le 10^9, 2 \le k \le 2000$。对于每个测试点，有以下约束（其中留空的表示没有特殊的约束）： 测试点编号 $n$ $m$ $k$ $1$ $\leq 10$ $\le 20$ $=2$ $2$ $\leq 100$ $\le 10^4$ $=2$ $3$ $\leq 1000$ $=2$ $4$ $\leq 10000$ $=2$ $5$ $\leq 10$ $\le 20$ $=3$ $6$ $\leq 100$ $\le 10^4$ $=3$ $7$ $\leq 1000$ $=3$ $8$ $\leq 10000$ $=3$ $9$ $\leq 10$ $\le 20$ $\le 100$ $10$ $\leq 100$ $\le 10^4$ $\le 100$ $11$ $\leq 1000$ $\le 1000$ $12$ $\leq 10000$ $13$ $\leq 10^5$ $\le 10^8$ $\le 100$ $14$ $\leq 2 \times 10^5$ $\le 1000$ $15$ $\leq 5 \times 10^5$ $16$ $\leq 10^6$ $\le 10^8$ $\le 100$ $17$ $\leq 2 \times 10^6$ $\le 1000$ $18$ $\leq 5 \times 10^6$ $19$ $\leq 10^7$ $\le 10^8$ $\le 100$ $20$ $\leq 2 \times 10^7$ $\le 1000$ $21$ $\leq 2 \times 10^7$ $22$ $\leq 10^8$ $\le 10^8$ $23$ $\leq 10^8$ $\le 10^8$ $24$ $25$ 这部分将提供一个将分数化为对应的小数的方法，如果你已经熟悉这个方法，你不必阅读本提示。 分数可以通过除法，用分子除以分母化为对应的小数。有些分数在除法过程中无法除尽,这样的分数在不断进行的除法过程中余数一定会重复出现。从商数的个位所对应的余数起，设第一次重复出现的余数前两次出现的位置所对应的商数位分别是小数点后第 $a$ 位和小数点后第 $b$ 位（特殊地：如果其中一个对应的商数位是个位，则认为 $a=0$；不妨设 $a&lt;b$），则其循环部分可以用小数点后第 $a+1$ 位到小数点后第 $b$ 位的循环来表示。 例如：在十进制下，将 $\frac{5}{11}$ 转化为小数时，个位开始的商数依次为 $4$,$5$,$4$,…，对应的余数分别为 $6$,$5$,$6$,…。余数第一次重复出现的位置是个位和小数点后第 $2$ 位,那么 $a=0$,$b=2$ $a=0$,$b=2$即其循环部分可以用小数点第 $1$ 位到第 $3$ 位来表示。表示为：$\frac{5}{11}=0.45454545…=0.\dot{4}\dot{5}$。 在十进制下，将 $\frac{1}{6}$ 转化为小数时,个位开始的商数依次为 $1$,$6$,$6$,…，对应的余数分别为 $4$,$4$,$4$,…。余数第一次重复出现的位置是小数点后第 $1$ 位和小数点后第 $2$ 位,即其循环部分可以用小数点后第 $2$ 位来表示。表示为：$\frac{1}{6}=0.1666……=0.1\dot{6}$。 需要注意的是：商数重复出现并不代表进入了循环节。 分析首先我们假设对于最简分数$\frac{x}{y}$，它的循环节的长度为$s$。（方括号表示取小数部分。）那么我们将小数点向后移动$s$的倍数为，它小数部分应该不变。如：十进制下$0.\dot{5}2\dot{0}$，移动$3$位后的$520.\dot{5}2\dot{0}$小数部分一样。那么我们用式子表示$k$进制下的上述结论：（为了方便，我们只移动移动$s$位。） \frac{x}{y} \times k^s - \lfloor \frac{x}{y} \times k^s \rfloor = \frac{x}{y} - \lfloor \frac{x}{y} \rfloor x \times k^s - \lfloor \frac{x}{y} \times k^s \rfloor \times y= x - \lfloor \frac{x}{y} \rfloor \times y x \times k^s \equiv x \pmod{y}由于上文我们已经要求$\frac{x}{y}$是最简分数，即$gcd(x,y)=1$。 k^s \equiv 1 \pmod{y}即对于最简分数$\frac{x}{y}$，如果它是一个纯循环小数，那么它满足$gcd(k,y)=1$。枚举分母与分子。那么答案就是 \sum_{i=1}^n \sum_{j=1}^m [gcd(i,j)=1] [gcd(j,k)=1]改变枚举顺序。 \sum_{j=1}^m [gcd(j,k)=1] \sum_{i=1}^n [gcd(i,j)=1]莫比乌斯反演一下。 \sum_{j=1}^m [gcd(j,k)=1] \sum_{i=1}^n \sum_{d|gcd(i,j)}\mu(d) \sum_{j=1}^m [gcd(j,k)=1] \sum_{i=1}^n \sum_{d|i,d|j}\mu(d) \sum_{d=1}^n \mu(d) \sum_{d|i}^n \sum_{d|j}^m [gcd(j,k)=1] \sum_{d=1}^n \mu(d) \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} [gcd(j \times d,k)=1] \sum_{d=1}^n [gcd(d,k)=1] \mu(d) \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} [gcd(j,k)=1] \sum_{d=1}^n [gcd(d,k)=1] \mu(d) \lfloor \frac{n}{d} \rfloor \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} [gcd(j,k)=1]我们设函数 f(x) = \sum_{i=1}^x[gcd(i,k)=1] g(x,k) = \sum_{i=1}^x[gcd(i,k)=1] \mu(i)即让$g(x)$表示第一个$\sum$后的一部分式子，让$f(x)$表示第二个$\sum$后的式子。现在考虑怎么求$f(x)$和$g(x)$。对于$f(x)$，我们考虑对$1$到$x$的所有数以每$k$个数为一段进行分段，那么就分成了：$\sum_{i=1}^k[gcd(i,j)=1]$，$\sum_{i=k+1}^{2k}[gcd(i,j)=1]$…显然上述每段的值相同因为对于每一个数，对于除第一段以外的其他段中的每个数，都可以看作$i+j \times k ( i \le k)$，而$gcd(i+j \times k,k)=gcd(i,j)$，所以除第一段以外的其他段的值都与第一段相同，且均为$f(k)$（定义）。但是我们不一定能恰好分完，即$x \%k \ne 0$。可能会剩下$\sum_{i=j \times k+1}^x[gcd(i,k)=1]$。根据$gcd(i,j)=gcd(i+j \times k,k)$。 \sum_{i=j \times k+1}^x[gcd(i,k)=1] \\ = \sum_{i=1}^x[gcd(i,k)=1] \\ = f(x\%k )我们可以分成$\lfloor \frac{x}{k} \rfloor$个整段。所以 f(x)=\lfloor \frac{x}{k} \rfloor \phi (k) + f(x\%k)$k$只有$2000$，可以直接暴力预处理出来。现在我们再考虑$g(x,k)$ g(x,k) = \sum_{i=1}^x[gcd(i,k)=1] \mu(i)这个式子不好求，所以我们需要再次莫比乌斯反演一下（QAQ）。 \sum_{i=1}^x[gcd(i,k)=1] \mu(i) \sum_{i=1}^x \mu(i) [gcd(i,k)=1] \sum_{i=1}^x \mu(i) \sum_{j|gcd(i,k)} \mu(j) \sum_{i=1}^x \mu(i) \sum_{j|i,j|k} \mu(j) \sum_{j|k} \mu(j) \sum_{j|i}^x \mu(i) \sum_{j|k} \mu(j) \sum_{i=1}^{\lfloor \frac{x}{j} \rfloor} \mu(i \times j)额，好像又化不动了。不过，可以发现如果$gcd(i,j) \ne 1$，那么$\mu(i \times j)=0$，因为有了平方因子。所以，继续化式子。 \sum_{j|k} \mu(j) \sum_{i=1,gcd(i,j) = 1}^{\lfloor \frac{x}{j} \rfloor} \mu(i) \mu(j) \sum_{j|k} \mu(j) \sum_{i=1}^{\lfloor \frac{x}{j} \rfloor} [gcd(i,j) = 1] \mu(i) \mu(j) \sum_{j|k} \mu(j)^2 \sum_{i=1}^{\lfloor \frac{x}{j} \rfloor} [gcd(i,j) = 1] \mu(i) \sum_{j|k} \mu(j)^2 g(\lfloor \frac{x}{j} \rfloor,j)于是$g(x,k)$可以递归求。边界条件$k=1$。当$k=1$时 g(x,k) \sum_{i=1}^x[gcd(i,k)=1] \mu(i) \sum_{i=1}^x[gcd(i,1)=1] \mu(i) \sum_{i=1}^x \mu(i)此时我们求$\mu(i)$的前缀和，上杜教筛即可。现在，$f(x)$和$g(x)$都求出来了。但答案里还有一项 $\lfloor \frac{n}{d} \rfloor$以及边界条件$\lfloor \frac{m}{d} \rfloor$。这个我们直接二维整除分块就行了。复杂度$O($能过$)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;#define maxk 2010#define lim 215445template &lt;typename T&gt;inline T read()&#123; register T sum=0; char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,m,K,f[maxk],mu[lim+10],prim[lim+10],sum[lim+10];long long ans;map&lt;int,int&gt;mp;map&lt;pair&lt;int,int&gt;,long long&gt;g;void init()&#123; mu[1]=1; for(int i=2;i&lt;=lim;i++) &#123; if(!prim[i]) &#123; prim[++prim[0]]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=prim[0]&amp;&amp;prim[j]*i&lt;=lim;j++) &#123; prim[prim[j]*i]=true; if(i%prim[j]==0)break; mu[prim[j]*i]=-mu[i]; &#125; &#125; for(int i=1;i&lt;=lim;i++)sum[i]=sum[i-1]+mu[i];&#125;int Get(int n)&#123; if(n&lt;=lim)return sum[n]; if(mp[n])return mp[n]; int ans=1; for(int l=2,r;l&lt;=n;l=r+1) &#123; r=n/(n/l); ans-=(r-l+1)*Get(n/l); &#125; return mp[n]=ans;&#125;long long G(int x,int k)&#123; if(x==0)return 0; if(k==1)return Get(x); if(g[make_pair(x,k)])return g[make_pair(x,k)]; long long ans=0; for(int i=1;i*i&lt;=k;i++) if(k%i==0) &#123; if(mu[i])ans+=G(x/i,i); if(i*i!=k&amp;&amp;mu[k/i])ans+=G(x/(k/i),(k/i)); &#125; return g[make_pair(x,k)]=ans;&#125;int F(int x)&#123; return (x/K)*f[K]+f[x%K];&#125;int gcd(int a,int b)&#123; return b? gcd(b,a%b):a;&#125;int main()&#123; init(); read(n,m,K); for(int i=1;i&lt;=K;i++) f[i]=f[i-1]+(gcd(i,K)==1); long long ls=0; for(int l=1,r;l&lt;=min(n,m);l=r+1) &#123; r=min(n/(n/l),m/(m/l)); long long t=G(r,K); ans+=(n/l)*(t-ls)*F(m/l); ls=t; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4094 [HEOI2016/TJOI2016]字符串]]></title>
    <url>%2F2019%2F05%2F08%2FP4094-HEOI2016-TJOI2016-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[P4094 [HEOI2016/TJOI2016]字符串传送门洛谷 题目描述佳媛姐姐过生日的时候，她的小伙伴从某东上买了一个生日礼物。生日礼物放在一个神奇的箱子中。箱子外边写了一个长为$n$的字符串s，和$m$个问题。佳媛姐姐必须正确回答这$m$个问题，才能打开箱子拿到礼物，升职加薪，出任CEO，嫁给高富帅，走上人生巅峰。每个问题均有$a,b,c,d$四个参数，问你子串$s[a..b]$的所有子串和$s[c..d]$的最长公共前缀的长度的最大值是多少？佳媛姐姐并不擅长做这样的问题，所以她向你求助，你该如何帮助她呢？ 输入输出格式输入格式：输入的第一行有两个正整数$n,m$，分别表示字符串的长度和询问的个数。接下来一行是一个长为$n$的字符串。接下来$m$行，每行有$4$个数$a,b,c,d$，表示询问$s[a..b]$的所有子串和$s[c..d]$的最长公共前缀的最大值。 输出格式：对于每一次询问，输出答案。 输入输出样例输入样例#1：5 5aaaaa1 1 1 51 5 1 12 3 2 32 4 2 32 3 2 4 输出样例#1：11222 说明对于$10\%$的数据，$1 \le n,m \le 300$ 对于$40\%$的数据，$1 \le n,m \le 3000$,字符串中仅有$a$,$b$ 对于$100\%$的数据，$1 \le n,m \le 10^5$,字符串中仅有小写英文字母，$a \le b,c \le d,1 \le a,b,c,d \le n$ 分析我们首先可以看出本题答案是有单调性的。因为如果一个串可以，那么它的前缀也一定可以，即如果一个答案满足题意，那么所有小于它的答案也都满足题意。既然有单调性，那么我们可以二分。我们二分$s[c…d]$的前缀长度为$len$。那么显然如果满足题意，那么$s[c…c+len-1]$一定是$s[a…b]$的子串。现在问题就转化成了给你一个串，判断它是不是另一个字符串的子串。似乎很多人都是用$SA$做的，可是本蒟蒻不会$SA$…所以我们想想$SAM$的做法。其实很好想如果它是子串，那么它一定在另一个串的$Endpos$中。我们就只需要判断是不是这个串的$Endpos$中有$a+len-1…b$中任何一个数出现。这个显然权值线段树可以搞定。那么我们怎么求$Endpos$集合？线段树合并就行了。还有一个小细节就是，不是直接在子串在$SAM$上的节点的线段树里找，而是一直往上跳祖先，直到这个节点的$len_i$是满足$len_i \ge len$的最小值。因为长度越小$Endpos$的元素越多，找到的概率就越大（说人话就是不会漏解）。另外，我不知道用$SAM$为什么一定要把串翻过来，不翻也照样做啊？ 吐槽：Owen_codeisking题解中的$SAM$解法阵亡了，弄得我对拍的时候一直以为我打错了，浪费了好多时间。hack数据：4 1mktk3 4 1 4正确输出：1 参考资料mrclr的 [HEOI2016/TJOI2016]字符串Owen_codeisking的 [HEOI2016/TJOI2016]字符串（后缀数组+二分+主席树/后缀自动机+倍增+线段树合并） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 100010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;struct Node&#123; int l,r; int val;&#125;node[maxn*60];int n,m,a,b,c,d,tot,cnt=1,las=1,T[maxn&lt;&lt;1],pac[maxn],ns[maxn&lt;&lt;1];int len[maxn&lt;&lt;1],fa[maxn&lt;&lt;1][21],ch[maxn&lt;&lt;1][26],ton[maxn&lt;&lt;1];void insert(int &amp;k,int l,int r,int x)&#123; if(!k)k=++tot; if(l==r) &#123; node[k].val+=1; return ; &#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)insert(node[k].l,l,mid,x); else insert(node[k].r,mid+1,r,x); node[k].val=node[node[k].l].val+node[node[k].r].val;&#125;int merge(int x,int y,int l,int r)&#123; if(!x||!y)return x+y; if(l==r) &#123; node[x].val+=node[y].val; return x; &#125; int mid=(l+r)&gt;&gt;1,z=++tot; node[z].l=merge(node[x].l,node[y].l,l,mid); node[z].r=merge(node[x].r,node[y].r,mid+1,r); node[z].val=node[node[z].l].val+node[node[z].r].val; return z;&#125;int query(int k,int l,int r,int x,int y)&#123; if(!k)return 0; if(l&gt;=x&amp;&amp;r&lt;=y)return node[k].val; int mid=(l+r)&gt;&gt;1; if(y&lt;=mid)return query(node[k].l,l,mid,x,y); if(x&gt;mid)return query(node[k].r,mid+1,r,x,y); return query(node[k].l,l,mid,x,y)+query(node[k].r,mid+1,r,x,y);&#125;void insert(int cc,int i)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; pac[i]=np; for(;p&amp;&amp;!ch[p][cc];p=fa[p][0])ch[p][cc]=np; if(!p)fa[np][0]=1; else &#123; int q=ch[p][cc]; if(len[q]==len[p]+1)fa[np][0]=q; else &#123; int nq=++cnt; len[nq]=len[p]+1; fa[nq][0]=fa[q][0]; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q][0]=fa[np][0]=nq; for(;p&amp;&amp;ch[p][cc]==q;p=fa[p][0])ch[p][cc]=nq; &#125; &#125;&#125;bool check(int mid)&#123; if(!mid)return true; int now=pac[c+mid-1]; for(int i=20;i&gt;=0;i--) if(fa[now][i]&amp;&amp;len[fa[now][i]]&gt;=mid) now=fa[now][i]; return query(T[now],1,n,a+mid-1,b);&#125;int main()&#123; read(n,m); for(int i=1;i&lt;=n;i++) &#123; insert(getchar()-'a',i); insert(T[pac[i]],1,n,i); &#125; for(int i=1;i&lt;=cnt;i++)ton[len[i]]+=1; for(int i=1;i&lt;=cnt;i++)ton[i]+=ton[i-1]; for(int i=1;i&lt;=cnt;i++)ns[ton[len[i]]--]=i; for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;21;j++) fa[ns[i]][j]=fa[fa[ns[i]][j-1]][j-1]; for(int i=cnt;i&gt;=1;i--) T[fa[ns[i]][0]]=merge(T[fa[ns[i]][0]],T[ns[i]],1,n); for(int i=1;i&lt;=m;i++) &#123; read(a,b,c,d); int l=0,r=min(b-a+1,d-c+1); while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid))l=mid+1; else r=mid-1; &#125; printf("%d\n",r); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>各省省选</tag>
        <tag>二分</tag>
        <tag>线段树</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1973 [NOI2011]Noi嘉年华]]></title>
    <url>%2F2019%2F05%2F04%2FP1973-NOI2011-Noi%E5%98%89%E5%B9%B4%E5%8D%8E%2F</url>
    <content type="text"><![CDATA[P1973 [NOI2011]Noi嘉年华传送门洛谷 题目描述$NOI2011$ 在吉林大学开始啦！为了迎接来自全国各地最优秀的信息学选手，吉林大学决定举办两场盛大的 $NOI$ 嘉年华活动，分在两个不同的地点举办。每个嘉年华可能包含很多个活动，而每个活动只能在一个嘉年华中举办。 现在嘉年华活动的组织者小安一共收到了$n$个活动的举办申请，其中第 $i$ 个活动的起始时间为 $S_i$，活动的持续时间为$T_i$。这些活动都可以安排到任意一个嘉年华的会场，也可以不安排。 小安通过广泛的调查发现，如果某个时刻，两个嘉年华会场同时有活动在进行（不包括活动的开始瞬间和结束瞬间），那么有的选手就会纠结于到底去哪个会场，从而变得不开心。所以，为了避免这样不开心的事情发生，小安要求不能有两个活动在两个会场同时进行（同一会场内的活动可以任意进行）。 另外，可以想象，如果某一个嘉年华会场的活动太少，那么这个嘉年华的吸引力就会不足，容易导致场面冷清。所以小安希望通过合理的安排，使得活动相对较少的嘉年华的活动数量最大。 此外，有一些活动非常有意义，小安希望能举办，他希望知道，如果第 $i$ 个活动必须举办（可以安排在两场嘉年华中的任何一个），活动相对较少的嘉年华的活动数量的最大值。 输入输出格式输入格式：输入的第一行包含一个整数 $n$，表示申请的活动个数。 接下来 $n$ 行描述所有活动，其中第 $i$ 行包含两个整数 $S_i$、$T_i$，表示第 $i$ 个活动从时刻$S_i$开始，持续 $T_i$ 的时间。 输出格式：输出的第一行包含一个整数，表示在没有任何限制的情况下，活动较少的嘉年华的活动数的最大值。 接下来 $n$ 行每行一个整数，其中第 $i$ 行的整数表示在必须选择第 $i$ 个活动的前提下，活动较少的嘉年华的活动数的最大值。 输入输出样例输入样例#1：58 21 55 33 25 3 输出样例#1：221222 说明【样例说明】 在没有任何限制的情况下，最优安排可以在一个嘉年华安排活动$1$, $4$，而在另一个嘉年华安排活动$3$, $5$，活动$2$不安排。 如果输出格式不正确（比如输出不足$n+1$行），得$0$分； 如果输出文件第一行不正确，而且后$n$行至少有一行不正确，得$0$分； 如果输出文件第一行正确，但后$n$行至少有一行不正确，得$4$分； 如果输出文件第一行不正确，但后$n$行均正确，得$6$分； 如果输出文件中的$n+1$行均正确，得$10$分。 分析首先离散化时间，因为显然与答案与时间的绝对大小没有关系，只取决与相对大小。思考转移的话，有一堆等着我们转移，显然一个个转移是很不优秀的，那么我们每次一块块转移。所以，设$tot _ {l,r}$为完全包含在$[l,r]$区间内的活动数。接下来考虑怎么$DP$。设$pre _ {i,j}$为在时间$[1,i]$，第一个会场选了$j$个活动，第二个会场最多可以选多少活动（因为要求活动较少的会场的活动数的最大值，那么确定一个，就让另一个最大）。考虑转移。显然，转移为： pre_{i,j} = max( pre_{k,j} + tot_{k,i} , pre_{k,j-tot_{k,i}} )第一个转移表示将$[l,r]$内的所有活动分到第一个会场，第一个转移表示将$[l,r]$内的所有活动分到第二个会场。答案就是$max(min(pre _ {cnt,j} , j ))$其中$cnt$为时间点个数。但这仅仅只解决了第一个问题。为了解决第二个问题，我们还要引入后缀$DP$（$pre$为前缀$DP$）$suf _ {i,j}$，$suf _ {i,j}$为在时间$[i,cnt]$，第一个会场选了$j$个活动，第二个会场最多可以选多少活动。转移和前缀$DP$差不多： suf_{i,j} = max( suf_{k,j} + tot_{i,k} , suf_{k,j-tot_{i,k}} )思考第二问。我们设$[l,r]$内的活动都被一个会场选择了，所以我们才能一块块转移。但我们不知道在$l$之前和$r$之后选择了多少活动，所以枚举一下。枚举$l$之前选择了$a$个活动，$r$之后选择了$b$个活动。我们设$f _ {i,j}$为要求活动较少的会场的活动数的最大值。那么转移如下： f_{i,j}=max(min( a+b+tot_{l,r} , pre_{l,a}+suf_{r,b} ))第一个转移是第一个会场选择的活动数，第二个转移是第二个会场选择的活动数，因为求较小值的最大值，所以先取$min$,再取$max$。但这里还有一个问题，就是$pre$和$suf$只是局部最优解，不一定是全局最优解。比如一个活动$[l’,r’]$，其中$l’&lt;l,r’&gt;r$，那么它显然不会被包含进$tot _ {l,r}$，而它即不属于$[1,l]$，又不属于$[r,cnt]$，那么$pre$和$suf$自然也不能包含它，它就废了。所以这样一定有问题。那么我们怎么解决它呢？我们可以枚举转移区间，对于第$i$个活动$[l_i,r_i]$，我们枚举$f _ {l,r} \ ( l &lt; l_i , r &gt; r_i) $，再取最大值就行了。正确性保证了，但复杂度爆炸了，是$O(n^4)$的。考虑优化。发现有单调性（看标签）。因为在 $pre _ {i,j}$ 中，$j$ 越小，就说明第一个会场在 $[1, i]$ 区间中选择的活动就越少，那么第二个会场就会选择更多。所以， $j$ 越小， $pre _ {i,j}$ 越大。即$pre$是一个单调函数，$suf$也一样。观察式子$min( a+b+tot _ {l,r} , pre _ {i,a}+suf _ {r,b} )$，显然对于一个之前最优决策点$a,b$，我们不可能通过同时增大$a$和$b$获得新的最优解。所以，我们将$b$从大到小扫一下就行了。 参考资料wu3412790的洛谷题解FlashHu的洛谷题解longlongzhu123的洛谷题解 代码向大佬们求助：$min( a+b+tot _ {l,r} , pre _ {l,a}+suf _ {r,b} )$区间端点$l$，$r$重合没事吗？还有，时间不应该是$s_i+t_i-1$吗？为什么我这样打就挂了？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 210#define INF 0x7ffffftemplate &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,cnt,ans,be[maxn],en[maxn],lsh[maxn],tot[maxn&lt;&lt;1][maxn&lt;&lt;1];int pre[maxn&lt;&lt;1][maxn],suf[maxn&lt;&lt;1][maxn],f[maxn&lt;&lt;1][maxn&lt;&lt;1];int val(int i,int j,int a,int b)&#123; return min(a+b+tot[i][j],pre[i][a]+suf[j][b]);&#125;int main()&#123; n=read&lt;int&gt;(); for(int i=1;i&lt;=n;i++) &#123; be[i]=read&lt;int&gt;(); en[i]=be[i]+read&lt;int&gt;(); lsh[++cnt]=be[i]; lsh[++cnt]=en[i]; &#125; sort(lsh+1,lsh+1+cnt); cnt=unique(lsh+1,lsh+1+cnt)-lsh-1; for(int i=1;i&lt;=n;i++) &#123; be[i]=lower_bound(lsh+1,lsh+1+cnt,be[i])-lsh; en[i]=lower_bound(lsh+1,lsh+1+cnt,en[i])-lsh; for(int j=1;j&lt;=be[i];j++) for(int k=en[i];k&lt;=cnt;k++) tot[j][k]+=1; &#125; for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;=n;j++) pre[i][j]=suf[i][j]=-INF; for(int i=1;i&lt;=cnt;i++) for(int j=0;j&lt;=tot[1][i];j++) for(int k=1;k&lt;=i;k++) &#123; pre[i][j]=max(pre[i][j],pre[k][j]+tot[k][i]); if(j&gt;=tot[k][i])pre[i][j]=max(pre[i][j],pre[k][j-tot[k][i]]); &#125; for(int i=cnt;i&gt;=1;i--) for(int j=0;j&lt;=tot[i][cnt];j++) for(int k=cnt;k&gt;=i;k--) &#123; suf[i][j]=max(suf[i][j],suf[k][j]+tot[i][k]); if(j&gt;=tot[i][k])suf[i][j]=max(suf[i][j],suf[k][j-tot[i][k]]); &#125; for(int i=1;i&lt;=n;i++)ans=max(ans,min(pre[cnt][i],i)); printf("%d\n",ans); for(int i=1;i&lt;=cnt;i++) for(int j=i+1;j&lt;=cnt;j++) for(int a=0,b=n;a&lt;=n;a++) &#123; int las=val(i,j,a,b); while(b&amp;&amp;las&lt;=val(i,j,a,b-1)) las=val(i,j,a,b-1),b-=1; f[i][j]=max(f[i][j],las); &#125; for(int i=1;i&lt;=n;i++) &#123; ans=0; for(int j=1;j&lt;=be[i];j++) for(int k=en[i];k&lt;=cnt;k++) ans=max(ans,f[j][k]); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>NOI</tag>
        <tag>单调性优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1396 识别子串]]></title>
    <url>%2F2019%2F05%2F03%2FBZOJ1396-%E8%AF%86%E5%88%AB%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[BZOJ1396 识别子串传送门BZOJ 题意描述 输入输出格式输入格式：一行,一个由小写字母组成的字符串$S$,长度不超过$10^5$。 输入格式：$L$行,每行一个整数,第$i$行的数据表示关于$S$的第$i$个元素的最短识别子串有多长. 输入输出样例输入样例#1：agoodcookcooksgoodfood 输出样例#1：1233223322332123321234 分析显然，可以用于更新答案的点一定是$Endpos$为$1$的点。更新的值是什么？根据$Parent$树的性质，一个点管辖的子串长中最短的子串长为父节点管辖的子串长中最长子串长$+1$，那么我们每次更新答案是就用$len _ {fa_i}+1$更新。更新区间，想想父节点管辖的子串长为$len _ {fa_i}$，此节点管辖的子串长为$len_i$，那么不属于父节点管辖但属于此节点管辖的区间就为$[len_i - len _ {fa_i},len_i]$。似乎是可以做了，但上述更新是不完全的。 举例说明bbbc 对于第三个位置答案应该是bc，但是c在更新的时候只用1更新了自己，而第三个b在更新的时候用3更新了[1,3]这个区间。$\uparrow$ 例子来自clover_hxy的bzoj 1396: 识别子串 （后缀自动机+线段树） 为了应对这种情况，我们加一个更新。即对于$[1,len_i - len _ {fa_i}-1]$段，可以用长度$len_i-i+1$更新。 $\uparrow$ 图来自Zig_zag的 bzoj1396 识别子串 先前在想，为什么$[1,len_i]$一定是识别子串，后来发现我们将子串$[1,len_i]$看作两部分，分别为$[1,len_i - len _ {fa_i}-1]$和$[len_i - len _ {fa_i},len_i]$，假设这个子串不是识别子串，即这个子串重复了，那么我们将它分为两部分以后，这两部分一定都重复了，而我们的$[len_i - len _ {fa_i},len_i]$这个子串一定不重复（$Endpos$为$1$），所以假设不成立，子串$[1,len_i]$是识别子串。 参考资料Zig_zag的 bzoj1396 识别子串clover_hxy的 bzoj 1396: 识别子串 （后缀自动机+线段树）nianheng的 题解 代码一次免调过？吓到自己了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 100010#define INF 0x7ffffffftemplate &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;struct Segment_Tree&#123; struct Node &#123; int val; int tag; Node() &#123; val=tag=INF; &#125; &#125;node[maxn&lt;&lt;2]; void down(int k) &#123; if(node[k].tag!=INF) &#123; node[k&lt;&lt;1].val=min(node[k&lt;&lt;1].val,node[k].tag); node[k&lt;&lt;1].tag=min(node[k&lt;&lt;1].tag,node[k].tag); node[k&lt;&lt;1|1].val=min(node[k&lt;&lt;1|1].val,node[k].tag); node[k&lt;&lt;1|1].tag=min(node[k&lt;&lt;1|1].tag,node[k].tag); node[k].tag=INF; &#125; &#125; void change(int k,int l,int r,int x,int y,int z) &#123; if(l&gt;=x&amp;&amp;r&lt;=y) &#123; node[k].val=min(node[k].val,z); node[k].tag=min(node[k].tag,z); return ; &#125; down(k); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)change(k&lt;&lt;1,l,mid,x,y,z); if(y&gt;mid)change(k&lt;&lt;1|1,mid+1,r,x,y,z); node[k].val=min(node[k&lt;&lt;1].val,node[k&lt;&lt;1|1].val); &#125; int query(int k,int l,int r,int x) &#123; if(l==r)return node[k].val; down(k); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)return query(k&lt;&lt;1,l,mid,x); return query(k&lt;&lt;1|1,mid+1,r,x); &#125;&#125;S,T;int n,las=1,cnt=1,fa[maxn&lt;&lt;1],len[maxn&lt;&lt;1],siz[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26];char str[maxn];void add(int cc)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; siz[np]=1; for(;p&amp;&amp;!ch[p][cc];p=fa[p])ch[p][cc]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][cc]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; fa[nq]=fa[q]; len[nq]=len[p]+1; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][cc]==q;p=fa[p])ch[p][cc]=nq; &#125; &#125;&#125;int main()&#123; scanf("%s",str+1); n=strlen(str+1); for(int i=1;i&lt;=n;i++)add(str[i]-'a'); for(int i=1;i&lt;=cnt;i++)siz[fa[i]]=0; for(int i=1;i&lt;=cnt;i++) &#123; if(siz[i]!=1)continue; int l=len[i]-len[fa[i]],r=len[i]; S.change(1,1,n,l,r,len[fa[i]]+1); if(l&gt;1)T.change(1,1,n,1,l-1,r); &#125; for(int i=1;i&lt;=n;i++) printf("%d\n",min(S.query(1,1,n,i),T.query(1,1,n,i)-i+1)); return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3724 [AH2017/HNOI2017]大佬]]></title>
    <url>%2F2019%2F05%2F03%2FP3724-AH2017-HNOI2017-%E5%A4%A7%E4%BD%AC%2F</url>
    <content type="text"><![CDATA[P3724 [AH2017/HNOI2017]大佬传送门洛谷 题目描述人们总是难免会碰到大佬。他们趾高气昂地谈论凡人不能理解的算法和数据结构，走到任何一个地方，大佬的气场就能让周围的人吓得瑟瑟发抖，不敢言语。 你作为一个 $OIER$，面对这样的事情非常不开心，于是发表了对大佬不敬的言论。 大佬便对你开始了报复，你也不示弱，扬言要打倒大佬。 现在给你讲解一下什么是大佬，大佬除了是神犇以外，还有着强大的自信心，自信程度可以被量化为一个正整数 $C$（ $1 \le C \le10^8$）， 想要打倒一个大佬的唯一方法是摧毁 Ta 的自信心，也就是让大佬的自信值等于 $0$（恰好等于$0$，不能小于 $0$）。 由于你被大佬盯上了，所以你需要准备好 $n$($1 \le n \le 100$)天来和大佬较量，因为这 $n$ 天大佬只会嘲讽你动摇你的自信，到了第$n+1$ 天，如果大佬发现你还不服，就会直接虐到你服，这样你就丧失斗争的能力了。 你的自信程度同样也可以被量化，我们用 $mc$ ($1 \le mc \le 100$)来表示你的自信值上限。 在第 $i$ 天（ $i \ge 1$），大佬会对你发动一次嘲讽，使你的自信值减小 $a_i$，如果这个时刻你的自信值小于 $0$ 了，那么你就丧失斗争能力，也就失败了（特别注意你的自信值为 $0$ 的时候还可以继续和大佬斗争）。 在这一天， 大佬对你发动嘲讽之后，如果你的自信值仍大于等于 $0$，你能且仅能选择如下的行为之一： 还一句嘴，大佬会有点惊讶，导致大佬的自信值 $C$ 减小 $1$。 做一天的水题，使得自己的当前自信值增加 $w_i$, 并将新自信值和自信值上限 $mc$ 比较，若新自信值大于 $mc$，则新自信值更新为 $mc$。例如， $mc=50$， 当前自信值为 $40$， 若$w_i=5$，则新自信值为 $45$，若 $w_i=11$，则新自信值为 $50$。 让自己的等级值 $L$ 加 $1$。 让自己的讽刺能力 $F$ 乘以自己当前等级 $L$，使讽刺能力 $F$ 更新为 $F \times L$。 怼大佬，让大佬的自信值 $C$ 减小 $F$。并在怼完大佬之后，你自己的等级 $L$ 自动降为 $0$，讽刺能力 $F$ 降为 $1$。由于怼大佬比较掉人品，所以这个操作只能做不超过 $2$ 次。 特别注意的是，在任何时候，你不能让大佬的自信值为负，因为自信值为负，对大佬来说意味着屈辱，而大佬但凡遇到屈辱就会进化为更厉害的大佬直接虐飞你。在第 $1$ 天，在你被攻击之前，你的自信是满的（初始自信值等于自信值上限 $mc$）， 你的讽刺能力 $F$ 是 $1$， 等级是 $0$。 现在由于你得罪了大佬，你需要准备和大佬正面杠，你知道世界上一共有 $m$（ $1 \le m \le 20$ ）个大佬，他们的嘲讽时间都是 $n$ 天，而且第 $i$ 天的嘲讽值都是 $a_i$不管和哪个大佬较量，你在第 $i$ 天做水题的自信回涨都是 $w_i$ 这 $m$ 个大佬中只会有一个来和你较量（ $n$ 天里都是这个大佬和你较量），但是作为你，你需要知道对于任意一个大佬，你是否能摧毁他的自信，也就是让他的自信值恰好等于 $0$。和某一个大佬较量时，其他大佬不会插手。 输入输出格式输入格式：第一行三个正整数 $n,m,mc$。分别表示有 $n$ 天和 $m$ 个大佬, 你的自信上限为 $mc$。 接下来一行是用空格隔开的 $n$ 个数，其中第 $i$($1 \le i \le n$)个表示 $a_i$。 接下来一行是用空格隔开的 $n$ 个数，其中第 $i$($1 \le i \le n$)个表示 $w_i$。 接下来 $m$ 行，每行一个正整数，其中第 $k$($1 \le k \le m$)行的正整数 $C_k$表示第 $k$ 个大佬的初始自信值。 输出格式：共 $m$ 行，如果能战胜第 $k$ 个大佬（让他的自信值恰好等于 $0$），那么第 $k$ 行输出 $1$，否则输出 $0$。 输入输出样例输入样例#1：30 20 3015 5 24 14 13 4 14 21 3 16 7 4 7 8 13 19 16 5 6 13 21 12 7 9 4 15 20 4 13 1222 21 15 16 17 1 21 19 11 8 3 28 7 10 19 3 27 17 28 3 26 4 22 28 15 5 26 9 5 263010182918293122811286 1 627271811261 输出样例#1：01101011000111111001 说明$20\%$数据保证: $1 \le n \le 10$。 另有 $20\%$数据保证:$1 \le C_i,n,mc \le 30$。 $100\%$数据保证: $1 \le n,mc \le 100,1 \le m \le 20,1 \le a_i,w_i \le mc,1 \le C_i \le10^8$ 分析首先仔细观察几种操作，发现只有一个和自己的自信值有关（操作2）。 因此，自己死不死与怼大佬无关。 所以，相当于拆成两个部分，一个是怼大佬，另外一个是让自己活着。所以，我们先做一次$dp$，求出最多可以空出多少天来怼大佬，也就是刷水题的最少次数。我们设$f _ {i,j}$表示在第$i$天，我们的自信值为$j$时刷水题的最少次数。显然： f_{i,j-a_i}=max(f_{i-1,j}+1) \\ f_{i,min(mc,j-a_i+w_i)}=max(f_{i-1,j})第一个方程表示我们硬抗大佬一击换取怼大佬的时间。第二个方程表示我们刷题补自信值避免被怼死。这样，恢复自信与怼大佬两个分开，互相不影响。现在的问题就变成了给你$N$天，能否怼死大佬？我们怼大佬只与两个因素有关：天数和嘲讽值。因此，求出所有的可行的天数和嘲讽值的集合，按照嘲讽值从大到小排序。至于怎么求，暴力$BFS$+判重就行了。不怼或者怼一次解决大佬的情况很容易判断。怼一次就是$C-f_1 \ge 0$且$C-f_1 \le D-d_1$，不怼就是 $C \ge 0$且$C \le D$。现在要解决的问题是怼两次大佬。不妨设两次怼大佬花费的天数分别是$d_1,d_2$，总共可以怼$D$天。嘲讽值分别是$f_1,f_2$。我们可以列出不等式： f_1+f_2 \le C \\ f_1+f_2+(D-d_1-d_2) \ge C很好理解，显然操作5是一次操作，所以如果$f_1+f_2 &gt; C$，那么大佬的自信值就小于$0$了，凉凉。第二个操作就是表示我们能够怼死大佬。但为什么第二个不等式可以大于$C$呢？因为我们是多次操作，等大佬的自信值等于$0$时就胜利了，不存在小于$0$的情况。考虑按照$f$为第一关键字，$d$为第二关键字排序。现在维护两个指针，分别从大往小和从小往大枚举，每次保证$f_1+f_2 \le C$因为我们固定了一个方向，不妨固定了$f_1$。所以，此时的定值是$f_1,d_1,D,C$。 那么，这个时候要求的就是$f2-d2$的最大值。在$f_2$从小到大扫的过程中，显然是单调的，因此不需要再从头开始扫，直接继承上一次的指针位置继续向后即可。 参考资料yybyyb的洛谷题解 这篇题解绝大部分抄转自yybyyb的洛谷题解。时钟之门的洛谷题解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;#define maxn 110#define INF 0x7ffffffftemplate &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;struct Node&#123; int x; int y; bool operator &lt; (const Node &amp;b) const&#123; if(x!=b.x)return x&lt;b.x; return y&lt;b.y; &#125;&#125;zt[maxn*maxn*maxn];struct Data&#123; int x; int y; int z;&#125;;int n,m,mc,cnt,D,MC,a[maxn],w[maxn],C[maxn],f[maxn][maxn];map&lt;Node,int&gt;mp;void bfs()&#123; queue&lt;Data&gt;Q; Q.push((Data)&#123;1,1,0&#125;); while(!Q.empty()) &#123; Data t=Q.front();Q.pop(); if(t.x==D)continue; Q.push((Data)&#123;t.x+1,t.y,t.z+1&#125;); if(t.z&gt;1&amp;&amp;1ll*t.y*t.z&lt;=1ll*MC&amp;&amp;!mp.count((Node)&#123;t.x+1,t.y*t.z&#125;)) &#123; zt[++cnt]=(Node)&#123;t.y*t.z,t.x+1&#125;; Q.push((Data)&#123;t.x+1,t.y*t.z,t.z&#125;); mp[(Node)&#123;t.x+1,t.y*t.z&#125;]=true; &#125; &#125;&#125;int main()&#123; read(n,m,mc); for(int i=1;i&lt;=n;i++)a[i]=read&lt;int&gt;(); for(int i=1;i&lt;=n;i++)w[i]=read&lt;int&gt;(); for(int i=1;i&lt;=m;i++)MC=max(MC,C[i]=read&lt;int&gt;()); for(int i=1;i&lt;=n;i++) for(int j=a[i];j&lt;=mc;j++) &#123; f[i][j-a[i]]=max(f[i][j-a[i]],f[i-1][j]+1); f[i][min(mc,j-a[i]+w[i])]=max(f[i][min(mc,j-a[i]+w[i])],f[i-1][j]); &#125; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=mc;j++) D=max(D,f[i][j]); bfs(); sort(zt+1,zt+1+cnt); for(int i=1;i&lt;=m;i++) &#123; if(C[i]&lt;=D) &#123; puts("1"); continue; &#125; int minn=-INF,flag=false; for(int j=cnt,k=1;j&gt;=1;j--) &#123; if(zt[j].x&lt;=C[i]&amp;&amp;C[i]-zt[j].x&lt;=D-zt[j].y) &#123; flag=true; break; &#125; while(k&lt;=cnt&amp;&amp;zt[j].x+zt[k].x&lt;=C[i]) minn=max(minn,zt[k].x-zt[k].y),k+=1; if(D-zt[j].y+zt[j].x+minn&gt;=C[i]) &#123; flag=true; break; &#125; &#125; puts(flag? "1":"0"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>各省省选</tag>
        <tag>DP</tag>
        <tag>APIO</tag>
        <tag>BFS</tag>
        <tag>单调性优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4980 【模板】Polya定理]]></title>
    <url>%2F2019%2F05%2F03%2FP4980-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91Polya%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[P4980 【模板】Polya定理传送门洛谷 题目描述给定一个$n$个点，$n$条边的环，有$n$种颜色，给每个顶点染色，问有多少种本质不同的染色方案，答案对$10^9+7$取模。 注意本题的本质不同，定义为：只需要不能通过旋转与别的染色方案相同。 输入输出格式输入格式：第一行输入一个$t$，表示有$t$组数据。 第二行开始，一共$t$行，每行一个整数$n$，意思如题所示。 输出格式：共$t$行，每行一个数字，表示染色方案数对$10^9+7$取模后的结果。 输入输出样例输入样例#1：512345 输出样例#1：131170629 说明$n \leq 10^9$$t \leq 10^3$ 分析$Burnside$引理对于每个置换$g$，我们定义$C(g)$为在置换$g$下保持不变的方案数。则有： 本质不同的方案数为$C(g)$的平均数。即： ans=\frac{1} {\left | G \right |} \sum _ { g \in G} C(g)证明需要用到群论，本蒟蒻不是很会，就不现丑了。 $Polya$定理$Polya$定理其实是对$Burnside$引理的具体化，提供了计算不动点的具体方法。由于$Burnside$引理每次需要枚举状态，显然无法让人接受。于是，$Polya$定理出现了。假设一个置换有$k$个循环，易知每个循环对应的所有位置颜色需一致，而任意两个循环之间选什么颜色互不影响。因此，如果有$m$种可选颜色，则该置换对应的不动点个数为$m^k$。用其替换$Burnside$引理中的$C(g)$，即$C(g)=m^k$。得到等价类数目为： \frac{1} {\left | G \right |} \sum _ {i=0} ^ {\left | G \right | } m ^ {k_i}其中$\left | G \right |$表示置换的数目，$k_i$表示第$i$个置换包含的循环个数。 本题考虑第$i$次旋转。显然一个的循环节长度是$\frac{lcm(n,i)}{i}$，形象的，想象你有一条长$i$的线段用来倍长，因为我们总长为$n$，所以倍长后的结果一定被$n$整除，那我们就将干脆设最终的长度的$lcm(n,i)$，而我们每次只能从一条长$i$的线段中取一个放入我们的循环中，那么我们的循环自然为$\frac{lcm(n,i)}{i}$。既然每个循环节长度是$\frac{lcm(n,i)}{i}$，我们有$n$个数放入循环节中，那么循环节个数就是$\frac{n}{\frac{lcm(n,i)}{i}}$，即$gcd(n,i)$。所以： ans=\frac{1} {\left | G \right |} \sum _ {i=0} ^ {\left | G \right | } m ^ {gcd(n,i)}再向式子中带入本题变量，得： ans=\frac{1} {n} \sum _ {i=0} ^ n n ^ {gcd(n,i)}但这样是过不了的，我们还要优化一波。 ans=\frac{1} {n} \sum _ {i=0} ^ n n ^ {gcd(n,i)} \\ = \frac{1} {n} \sum _ {j|n} ^ n n ^ j \sum _ {i=1} ^ {n} {[gcd(n,i) == j]} \\ = \frac{1} {n} \sum _ {j|n} ^ n n ^ j \sum _ {i=1} ^ { \frac{n}{j} } {[gcd(n,i \times j) == j]} \\ = \frac{1} {n} \sum _ {j|n} ^ n n ^ j \sum _ {i=1} ^ { \frac{n}{j} } {[gcd( \frac{n}{j} ,i) == 1]} \\ = \frac{1} {n} \sum _ {j|n} ^ n n ^ j \varphi ( \frac{n}{j} )其中$\varphi$为欧拉函数，我们可以在$O(\sqrt n)$的时间内求出。 参考资料$Burnside$引理 &amp; $Polya$定理QAQqwe的 Burnside引理与Polya定理TenderRun的我对Burnside定理的理解周道-Althen的 超低能解读群论 本题SLF_LLL_SPFA的洛谷题解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define p 1000000007template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int T,n;int fpow(int x,int y)&#123; int ans=1; while(y) &#123; if(y&amp;1)ans=(1ll*ans*x)%p; x=(1ll*x*x)%p; y&gt;&gt;=1; &#125; return ans;&#125;int phi(int x)&#123; int ans=x; for(int i=2;i*i&lt;=x;i++) &#123; if(x%i==0) &#123; ans=ans/i*(i-1); while(x%i==0)x/=i; &#125; &#125; if(x!=1)ans=ans/x*(x-1); return ans%p;&#125;int main()&#123; T=read&lt;int&gt;(); for(int tot=1;tot&lt;=T;tot++) &#123; n=read&lt;int&gt;(); int ans=0; for(int i=1;i*i&lt;=n;i++) if(n%i==0) &#123; ans=(ans+(1ll*fpow(n,i)*phi(n/i))%p)%p; if(n/i!=i)ans=(ans+(1ll*fpow(n,n/i)*phi(i))%p)%p; &#125; ans=(1ll*ans*fpow(n,p-2))%p; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>Polya定理</tag>
        <tag>Burnside引理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2197 【模板】nim游戏]]></title>
    <url>%2F2019%2F05%2F03%2FP2197-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91nim%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[P2197 【模板】nim游戏传送门洛谷 题目描述甲，乙两个人玩$Nim$取石子游戏。 $nim$游戏的规则是这样的：地上有$n$堆石子（每堆石子数量小于$10000$），每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这$n$堆石子的数量，他想知道是否存在先手必胜的策略。 输入输出格式输入格式：第一行一个整数$T \le 10$,表示有$T$组数据 接下来每两行是一组数据，第一行一个整数$n$，表示有$n$堆石子，$n \le 10000$; 第二行有$n$个数，表示每一堆石子的数量 输出格式：共$T$行，如果对于这组数据存在先手必胜策略则输出”$Yes$”,否则输出”$No$”，不包含引号，每个单词一行。 输入输出样例输入样例#1：221 121 0 输出样例#1：NoYes 分析本题可以就题论题，但本文对本题不做过多证明（我才不会告诉你是我证不来）。介绍比较通用的解法——博弈$SG$。 博弈SG简介公平游戏是一种双人游戏，在游戏中双方都有完整的信息，没有牵涉，任何状态的合法操作对双方来说都是相同的。而在公平游戏中，$SG$函数和$SG$定理是一个十分神奇的东西，有了它，绝大部分的博弈都可以被统一到这个上面，都可以使用$SG$函数解决。是一种解决博弈问题的十分方便的手段。 前置知识首先，我们定义$mex$运算（排斥运算），其运算结果是传入参数中没有出现的第一个非负整数。举个例子：$mex(1,2,3)=0$ $mex(0,1,2)=3$ $mex(0,2,3)=1$很好理解，对吧？我们可以抽象一下。由于博弈是单人游戏，而且有“双方都做出最优决策”这一点限制了，所以最后的结果只取决于你面对的局面。很简单，如果结果像象棋一样取决与你和对手的策略（不一定最优），那还叫你做什么，这又不是交互式题目。开始即结束，大家一开始就知道结果了，是不是有点凄凉？那么我们所谓的$SG$值其实是指这一局面的$SG$值。既然我们的$SG$值只取决于局面，那我们将局面看作一个个点，如果我们有操作可以使得局面$A$变成局面$B$，那么我们在局面$A$所代表的点和局面$B$所代表的点连边，方向从局面$A$所代表的点和局面$B$所代表的点，同时我们称状态$B$是状态$A$的后继状态。然后画画图，我们发现，这就是个$DAG$。 $\uparrow$ 图来自龙杉老师的Sprague-Grundy Function-SG函数—博弈论(3)。 然后我们定义的$P$状态和$N$状态。$P$状态（$Positive$状态），指在这一局面下存在使操作者胜利的操作方法。$N$状态（$Negative$状态），指在这一局面下不存在存在使操作者胜利的操作方法。其中汇点是$P$状态。那么我们考虑如何推导当前状态。有一个很显然的定理（不知道算不算定理，姑且算定理）。对于每一个$P$状态，它的后继状态一定全是$N$状态。对于每一个$N$状态，它的后继状态有一部分是$P$状态。逆定理也成立。口胡证明一波，如果当前状态的后继状态有$P$状态，那么根据“双方都做出最优决策”限制，对手一定会做操作将当前状态变成后继状态中的$P$状态，那么你就挂了，所以是$N$状态，而如果当前状态的后继状态全是$N$状态，对手怎么操作都是$N$状态，那么它就挂了，所以是$P$状态。 $\uparrow$ 图来自龙杉老师的Sprague-Grundy Function-SG函数—博弈论(3)。 现在就介绍$Sprague-Grundy$定理（$SG$定理）：如果$Game_1$和$Game_2$是公平游戏，那么他们的总游戏是另一个公平游戏（$Game_1$和$Game_2$是子游戏）。总游戏规则：在每个回合，一个玩家玩其中一个游戏，不碰另一个游戏。当 $Game_1$ 和 $Game_2$ 都结束时总游戏结束。 如果 $Graph_1 = (V_1, E_1)$ 和 $Graph_2 = (V_2, E_2)$是$Game_1$和$Game_2$分别的$DAG$，那么我们将总游戏 $Graph = (V _ {sum}, E _ {sum}) $规定为： V _ {sum} = V1 \cup V2 \\ E _ {sum} = E1 \cup E2如果我们有这两个游戏的$DAG$——$Graph_1$和$Graph_2$。并且我们知道单个游戏的P状态和N状态。那么我们能够知道总游戏的$DAG$吗？显然不行。不难看出两个P状态的和总是P状态，P状态和N状态的和总是N状态。但是两个N状态的和既可能是P状态也可能是N状态。因此，只知道单个游戏的P状态和N状态是不够的。 所以为了正确地玩游戏和我们需要推广$P$状态和$N$状态，它就是$Sprague-Grudy$函数（$SG$函数）。我们定义$SG$函数的值$SG_x = mex ( SG_y ) | (x,y) \in E _ {sum}$。 $\uparrow$ 图来自龙杉老师的Sprague-Grundy Function-SG函数—博弈论(3)。 那么它有什么性质吗？肯定有啊。 性质1：点$x$是$P$状态当且仅当$SG_x=0$性质2：如果$Graph = Graph_1 + Graph_2$且 点$x = x_1+x_2$ 是$Graph$的一个点，那么$SG_x$ 为$SG _ {x_1}$ 和 $SG _ {x_2}$ 在二进制下的异或：即 g(v) = g(v1) \oplus g(v2).也称作$nim$和。 实现对于一个游戏，我们先将其分为几个互不相干的子游戏，求出每个子游戏的$SG$值，再用$nim$和合并一下就知道了总游戏的状态，然后看看是$P$态还是$N$态就知道结果了。嗯…似乎很有道理。但子游戏的$SG$值怎么求呢？ 1.可选步数为1~m的连续整数，直接取模即可，SG(x) = x % (m+1);2.可选步数为任意步，SG(x) = x;3.可选步数为一系列不连续的数，用模板计算。方法一：打表 $f[]$可以取走的石子个数,注意$f[]$需要从小到大排序 $sg[]$$SG$函数值；$vis[]$标记数组，用于求$mex{}$1234567891011121314151617181920int f[MAXN],sg[MAXN];bool vis[MAXN];void getSG(int n)&#123; sort(f+1,f+1+n); memset(sg,0,sizeof(sg)); for (int i=1; i&lt;=n; i++) &#123; memset(vis,0,sizeof(vis)); for (int j=1; f[j]&lt;=i; j++)//f排序是为了让每一种取法都循环到 vis[sg[i-f[j]]]=1; for (int j=0; j&lt;=n; j++) &#123; if (vis[j]==0) &#123; sg[i]=j; break; &#125; &#125; &#125;&#125; 方法二：$dfs$ $s$数组是定义特殊取法规则的数组，注意要按照从小到大排序；$n$表示集合大小 $SG$函数要初始化为$-1$，每个集合只需初始化一遍1234567891011121314151617181920212223int s[MAXN],sg[MAXN],n;bool vis[MAXN];int SG_dfs(int x)&#123; if (sh[x]!=-1) return sg[x]; memset(vis,0,sizeof(vis)); for (int i=0; i&lt;n; i++) &#123; if (x&gt;=s[i]) &#123; SG_dfs(x-s[i]); vis[sg[x-s[i]]]=1; &#125; &#125; int i=0; while (1) &#123; if (!vis[i]) return sg[x]=i; i++; &#125;&#125; $\uparrow$ 方法和代码来自秋日私语的洛谷题解。 本题说了这么多，还是要回归本题。首先分解本题的子问题，就是一堆$n$个石子，两人分别取石子知道没有办法再取游戏结束。根据$SG$函数值求法第2条：$SG_n=n$于是用$nim$和搞出本题总$SG$函数值。即 SG_{sum} = SG_{x_1} \oplus SG_{x_2} \oplus ... \oplus SG_{x_n} \\ = x_1 \oplus x_2 \oplus ... \oplus x_n再用$SG$函数值的性质判状态。这就是本题解法的来历。博弈$SG$一波带走。之前没学过博弈$SG$的时候一直不知道这个简单的异或做法是怎么来的，结果学了博弈$SG$就是道水题。 参考资料博弈SG龙杉老师的 Sprague-Grundy Function-SG函数—博弈论(3) 讲的非常详细。秋日私语的 [学习笔记] （博弈论）Nim游戏和SG函数 有经典模型和题目总结。Enstein_Jun的 组合游戏 - SG函数和SG定理Must_so的 ACM博弈学习小结Flying_Fatty的 博弈 SG函数 拓展资料自为风月马前卒的 博弈论进阶之Multi-SG自为风月马前卒的 博弈论进阶之Every-SGmyjs999的 博弈论 SG函数 SG定理kuangbin的 【转】博弈-翻硬币游戏celia01的 由poj 1067引发的——取石子游戏【各类取石子总结】 各类博弈问题的总结。 本题秋日私语的洛谷题解 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int T,n;int main()&#123; T=read&lt;int&gt;(); for(int tot=1;tot&lt;=T;tot++) &#123; n=read&lt;int&gt;(); int tmp=0; for(int i=1;i&lt;=n;i++)tmp^=read&lt;int&gt;(); puts(tmp? "Yes":"No"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>博弈SG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4718 【模板】Pollard-Rho算法]]></title>
    <url>%2F2019%2F05%2F02%2FP4718-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91Pollard-Rho%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[P4718 【模板】Pollard-Rho算法传送门洛谷 题目描述Miller Rabin算法是一种高效的质数判断方法。虽然是一种不确定的质数判断法，但是在选择多种底数的情况下，正确率是可以接受的。 Pollard Rho是一个非常玄学的方式，用于在$O(n^{1/4})$的期望时间复杂度内计算合数n的某个非平凡因子。事实上算法导论给出的是$O(\sqrt p)$，$p$是$n$的某个最小因子，满足$p$与$n/p$互质。但是这些都是期望，未必符合实际。但事实上Pollard Rho算法在实际环境中运行的相当不错。 这里我们要写一个程序，对于每个数字检验是否是质数，是质数就输出Prime；如果不是质数，输出它最大的质因子是哪个。 输入输出格式输入格式：第一行，$T$代表数据组数（不大于$350$） 以下$T$行，每行一个整数$n$，保证$1\le n\le 10^{18}$。 输出格式：输出$T$行。 对于每组测试数据输出结果。 输入输出样例输入样例#1：6213134889712345676543211000000000000 输出样例#1：PrimePrime674146495 分析先讲讲算法。 Miller-Rabin算法简介Miller-Rabin算法是一种可以快速判定大质数的随机算法，有一定概率阵亡。嗯…好像讲完了。 前置知识首先，我们需要知道一个定理——费马小定理。 a^{p-1} \equiv 1 \pmod{p}其次，我们还需要知道一个定理(不知道算不算定理，以下姑且将其称为定理)对于一个奇质数$p$且$e \ge 1$，满足$a^2 \equiv 1 \pmod {p^e}$的根只有平凡平方根。严格的证明不会，口胡一下还是会的。首先我们化式子。 a^2 \equiv 1 \pmod {p^e} a^2-1 \equiv 0 \pmod {p^e} (a+1) \times (a-1) \equiv 0 \pmod {p^e}即，$p \mid (a+1)$或者$p \mid (a-1)$。然后分情况讨论再合并，就是上面这个东西了。于是Miller和Rabin就捣鼓出了传说中的Miller-Rabin素性测试算法。 实现Miller-Rabin算法的主体思路很简单。首先，随机一个数$a$。想想费马小定理，我们想知道一个数$n$是不是素数，就验证一下$a^{n-1} \equiv 1 \pmod p$这个式子是否成立。但这样是有几率误判的（因为费马小定理的逆定理本来就是错的）。如取$a=2$，在前10亿个自然数中共有$50847534$个素数，而满足$2^{n-1} \equiv 1 \pmod p$的合数有$5597$个。这样算下来，算法出错的可能性约为$0.00011$。我们无法接受。无法接受归无法接受，我们还是得用它。所以想办法提升它的正确性。还记得第二条定理吗？我们将$a^{p-1}$拆开，拆成$a^{d \times 2^s}$，那么就像相当于将$a^d$一直平方，就可以套第二个式子了。当然能通过上面两个定理的检验的假素数还是有的（藏在数群中带着素数的面具勾搭素MM）。所以，我们还需要多次取数检验提高正确率。通常认为，Miller-Rabin算法中随机选取$ k$个底数进行测试的失误率大概为$4^{-k}$。 Miller-Rabin算法中，一般情况下底数随机选取，但当待测数不太大时，选择测试底数就有一些技巧了。比如，如果被测数小于$4759123141$，那么只需要测试三个底数$2, 7$和$61$就足够了。如果你每次都用前$7$个素数($2, 3, 5, 7, 11, 13$和$17$)进行测试，所有不超过$341550071728320$的数都是正确的。如果选用$2, 3, 7, 61$和$24251$作为底数，那么$10^{16}$内唯一的强伪素数为$46856248255981$。这样的一些结论使得Miller-Rabin算法在OI中非常实用。$\uparrow$ 这段底数选取的数据来自Norlan的素数与素性测试（Miller-Rabin测试）。 Pollard-Rho算法Pollard-Rho算法的主要思想是找因子分解，这个因子不一定是质因子。那么问题就在于如何找到它的因子。首先我们知道Pollard-Rho算法是一个随机算法，那么我们找因子自然是随机。但每次生成一个数显然撞上的可能性太小，那么根据生日悖论，我们每次多生成一些的话，且每次我们尝试的数为$x-y$（$x,y$为我们生成的随机数，下文一样），撞上的可能性就会增加。但这样我们又面临这一个问题，我们的程序可以调用的内存是有限的，如果我们每次生成很多数，空间就爆炸了。真是一个令人尴尬的问题。好在已经被解决了，要不然要这算法有何用。因为我们每次只调用两个随机数，提前把全部随机数生成好毫无意义。那么我们就按照一定顺序生成数。于是就有了一个伪随机数生成函数—— f(x)=x^2+a \pmod n其中$a$是我们随机的一个数（个人觉得很像随机种子）。那么我们就用了一系列随机数，还不用将其全部存放与内存中。但Pollard-Rho算法的精髓还不止这一点。我们发现尽管生成了一串随机数，但要求能整除$n$，这样的数被撞上的概率还是不足以让人满意。于是Pollard又想出了一个办法。概率不然人满意，是不是我们对生成的数要求太高了。那换个要求，我们要求$gcd(x-y,n)&gt;1$。这样的数又$x,2x,…,(y-1)x,y,2y,…,(x-1)y$，共$x+y-2$个数。于是成功率可以让人接受了。但算法还是不怎么完美，因为我们的伪随机数生成函数是长这样的。$\uparrow$ 图来自 努力努力再努力x 的 大数因式分解 Pollard_rho 算法详解 很像希腊字母$\rho$，这也是算法名字中Rho的来历。于是新的问题再次被提了出来。怎么判断环？？？如果把生成的数都存下来判环，我们使用这个函数的意义就没有了。好在前人已经帮我们解决了这个问题。我们可以使用Floyd判环法。想象两个人A,B在一个环形跑道上奔跑，我们让A的速度是B的两倍，当A第一次赶上B时，我们就知道B一定比A多跑了一圈。但实际应用中我们采用的是brent判环法（因为更高效），具体的，就是倍增，让A每次比B多跑$2^i$步。吐槽：我说我怎么看不懂他们在写什么，原来是因为我不知道我写的是brent判环法，还以为我们都是用的Floyd判环法。 连判环法都认不出来的蒟蒻一只，还有，觉得Floyd判环法好丑好麻烦。来来来，我们分析一波复杂度。根据生日悖论，每 $k = \sqrt n$个人中有 $50\%$的可能性产生生日冲突的话。那么这个算法的期望复杂度应该是带一个根号的，粗略的说，我们试一个数，原来试到的概率为$\frac{1}{n}$，加上生日悖论的话，变成$\sqrt \frac {1}{n}$，现在有$x+y-2$个数可以成功，再乘一下，概率还是比较大。所以期望复杂度感觉上虽然带个根号，当应该不会很高。事实上，算法导论上给出的期望复杂度为$O( \sqrt p )$，$p$为$n$的某个最小因子，满足$p$与$n/p$互质。证明见算法导论。好像还可以当作$O( n ^ \frac{1}{4} )$来算。 参考资料Miller-Rabin算法努力努力再努力x的 大素数测试的Miller-Rabin算法Norlan的 素数与素性测试（Miller-Rabin测试） 讲的非常好，语言也很生动形象，很多本文由于作者懒没有提到的的定义，证明，定理以及有趣的历史都可以在上面找到。 Pollard-Rho算法book丶book丶的 Pollard_rho 因数分解 主要看判环法的代码。Doggu的 大数质因解：浅谈Miller-Rabin和Pollard-Rho算法 以及由Doggu翻译的一篇文章 感觉两篇文章都非常好，很多本人没法证明的或者是解释不清楚的都可以在这两篇文章里找到。努力努力再努力x的 大数因式分解 Pollard_rho 算法详解cz_xuyixuan的 【学习笔记】Pollard’s rho算法 写的比较详细，不过本人理解起来较为困难，提供神奇的优化。Great_Influence的洛谷题解 Pollard-Rho 变成了 Pollard−Pho ：) $46856248255981$好像可以被其他数字判掉？？？学到了。 代码不要打龟速乘，不要打龟速乘，不要打龟速乘打$O(1)$快速乘，亲测龟速乘跑$4s$，快速乘跑$0.5s$。为什么我一个每个数$gcd$一下$Wa$了，优化算法复杂度的时候每$127$个数$gcd$一下，竟然$A$了，优化复杂度怎么优化到正确性上去了？？？卡常卡死我了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;time.h&gt;using namespace std;template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int T;long long ans;const long long MR[]=&#123;2,3,7,61,24251&#125;;//long long mul(long long x,long long y,long long p)//&#123;// long long ans=0;// while(y)// &#123;// if(y&amp;1)ans=(ans+x)%p;// x=(x+x)%p;// y&gt;&gt;=1;// &#125;// return ans;//&#125;inline long long mul(long long x,long long y,long long mod)&#123; long long tmp=(x*y-(long long)((long double)x/mod*y+1.0e-8)*mod); return tmp&lt;0 ? tmp+mod : tmp;&#125;inline long long add(long long x,long long y,long long p)&#123; long long tmp=x+y; if(tmp&gt;p)tmp-=p; return tmp;&#125;inline long long fpow(long long x,long long y,long long p)&#123; long long ans=1; while(y) &#123; if(y&amp;1)ans=mul(ans,x,p); x=mul(x,x,p); y&gt;&gt;=1; &#125; return ans;&#125;long long gcd(long long x,long long y)&#123; return y? gcd(y,x%y):x;&#125;inline bool Miller_Rabin(long long n)&#123; if(n==2||n==3)return true; if(n%2==0||n==1||n==46856248255981)return false; long long d=n-1; int s=0; while(!(d&amp;1))s+=1,d&gt;&gt;=1; for(int i=0;i&lt;5;i++) &#123; if(n==MR[i])return true; if(n%MR[i]==0)return false; long long x=fpow(MR[i],d,n),y=0; for(int j=1;j&lt;=s;j++) &#123; y=mul(x,x,n); if(y==1&amp;&amp;x!=1&amp;&amp;x!=n-1)return false; x=y; &#125; if(y!=1)return false; &#125; return true;&#125;inline long long Irand(long long x)&#123; return 1ll*((rand()&lt;&lt;15^rand())&lt;&lt;30^(rand()&lt;&lt;15^rand()))%x;&#125;inline long long Pollard_Rho(long long n,long long c)&#123; long long x=Irand(n-1)+1; long long y=x,k=2,val=1; for(int i=1;;i++) &#123; x=add(mul(x,x,n),c,n); val=mul(val,add(y-x,n,n),n); if(i%127==0) &#123; long long d=gcd(val,n); if(d!=1&amp;&amp;d!=n)return d; val=1; &#125;// long long d=gcd(add(y-x,n,n),n);// if(d!=1&amp;&amp;d!=n)return d; if(x==y)return n; if(i==k) &#123; long long d=gcd(val,n); if(d!=1&amp;&amp;d!=n)return d; val=1; y=x; k&lt;&lt;=1; &#125; &#125;&#125;void Find(long long n,long long c)&#123; if(n==1||n&lt;=ans)return ; if(Miller_Rabin(n)) &#123; ans=max(n,ans); return ; &#125; long long p=n; while(p&gt;=n)p=Pollard_Rho(p,c--); Find(p,c); Find(n/p,c);&#125;int main()&#123; srand(19491001); T=read&lt;int&gt;(); for(int tot=1;tot&lt;=T;tot++) &#123; long long x=read&lt;long long&gt;(); if(!Miller_Rabin(x)) &#123; ans=0; Find(x,100); printf("%lld\n",ans); &#125; else puts("Prime"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>Miller-Rabin算法</tag>
        <tag>Pollard-Rho算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF321E Ciel and Gondolas / BZOJ5311 贞鱼]]></title>
    <url>%2F2019%2F04%2F30%2FCF321E-Ciel-and-Gondolas-BZOJ5311-%E8%B4%9E%E9%B1%BC%2F</url>
    <content type="text"><![CDATA[CF321E Ciel and Gondolas / BZOJ5311 贞鱼传送门洛谷BZOJ 题意描述众所周知，贞鱼是一种高智商水生动物。不过他们到了陆地上智商会减半。这不？他们遇到了大麻烦！$n$只贞鱼到陆地上乘车，现在有$k$辆汽车可以租用。由于贞鱼们并不能在陆地上自由行走，一辆车只能载一段连续的贞鱼。贞鱼们互相有着深深的怨念，每一对贞鱼之间有怨气值。第$i$只贞鱼与第$j$只贞鱼的怨气值记为$Y _ {i,j}$，且$Y _ {i,j}$=$Y _ {j,i}$，$Y _ {i,i}$=0。每辆车载重不限，但是每一对在同辆车中的贞鱼都会产生怨气值。当然,超级贞鱼zzp长者希望怨气值的总和最小。不过他智商已经减半,想不出分配方案。他现在找到了你,请你帮助他分配贞鱼们,并输出最小怨气值之和$ans$。 输入输出格式输入格式：第一行两个整数:$n$,$k$。接下来读入一个$n$行$n$列的矩阵。矩阵中第$i$行$j$列的元素表示$Y _ {i,j}$。当然这个矩阵是对称的。 输出格式：一个整数$ans$，表示：最小的怨气值之和★注意：同辆车中，贞鱼$i$,$j$之间的怨气只算一次！$1 \le n \le 4000 ，1 \le k \le min(n , 800) , 0 \le Y _ {i,j} \le 10 $ 输入输出样例输入样例#1：8 30 1 1 1 1 1 1 11 0 1 1 1 1 1 11 1 0 1 1 1 1 11 1 1 0 1 1 1 11 1 1 1 0 1 1 11 1 1 1 1 0 1 11 1 1 1 1 1 0 11 1 1 1 1 1 1 0 输出样例#1：7 说明【样例解释1】编号为1，2，3的贞鱼一辆车：怨气值和为3；编号为4，5，6的贞鱼一辆车：怨气值和为3；编号为7，8的贞鱼一辆车：怨气值和为1。最小怨气值总和为 3 + 3 + 1 = 7 。 分析本题也是$WQS$二分的模板题，但困扰本蒟蒻的不是$WQS$二分，而是$DP$，众所周知，本题的状态转移方程式为 f_i=min\left(f_j+\cfrac{sum_{i,i}+sum_{j,j}-sum_{i,j}-sum_{j,i}}{2}\right)(1 \le j < i)其中$f_i$为考虑到第$i$只贞鱼，$sum _ {i,j}$表示矩阵$(1,1),(i,1),(1,j),(i,j)$之和。据说这个式子满足决策单调性。决策单调性是什么？？？就是说如果存在$f_a$比$f_b$小，那么就不可能从$f_a$转移过来。为什么？？？上网找了很多题解，要么不会证，要么强到不想证（菜是原罪）终于…发现一位巨佬——T_Y_P_E。蒟蒻在Ta的博客里找到了证明和做法，以下转自T_Y_P_E的题解。 选择单调性的话，是和dp值的增长率的大小有关的。如果不懂的话，可以看一下下面这个图。首先将式子中的对于i而言的非常数项提出来：-(sum[i][j]+sum[j][i]-sum[j][j])，然后下面的图表现的是括号里面(先令作F(i,j))的几何意义。j1&lt;j2是显然的.其中橙色部分v表示的就是F(i,j2)随i的变化量，而绿色部分就是F(i,j1)随i的变化量。可见delta(F(i,j2))是大于delta(F(i,j1))的，也就是说dp是中和sum[][]有关的那一坨中中，如果j1&lt;j2，因为对于j1和j2而言，sum[i][i]的增加率肯定是相等的，而F(i,j1)增加的要慢一些，也就是它阻碍sum[i][i]增加的作用要小一些，那么对应的j1的总的增加量就要大一些。 因为我们要求的是最小值，而此时如果dp[j1]还大于dp[j2]的话，在i增大的过程中，j1是绝对不可能成为决策点的。于是就可以把j1舍去了。 这里博主可能说的有些复杂，能理解就好。 这样子就可以利用决策单调性把整体时间复杂度优化到O(nlognlogmaxval)了。至于决策单调性的具体过程，大概就是先发现一个决策点对一个连续的区间进行转移，所以可以在队列里面放入一个决策点当前能够更新的左右端点和自己的下标。 首先先默认能够更新到n，然后在之后的插入决策点的过程中，将绝对不可能进行之后的转移的点弹掉，然后在一个完整的区间内部进行二分，将这个区间拆成两个，其中右边的那个就是新插进去的决策点的更新区间啦。 若您认为转载效果不佳，可在下方找到原博客网址。 学习完巨佬的优化后，本题就可以做了。但本蒟蒻还想转一下巨佬的提示。 1.在最后算答案加回多算的代价的时候，记得是每辆车多算的代价乘上k，而不是乘上你这个方案的车的数量2.在DP的转移过程中，除了要将值的大小设为第一比较关键字外，还要将选取车的数量设为第二关键字进行比较。通常是这样的：如果你在外层的二分中是判定当前选取车的数量&lt;= k的时候算答案的话，你在内层就要保证在dp值相同的情况下，尽可能地少使用车；反之亦然（全部反过来就行了）。 真是叫人半懂不懂的。蒟蒻还要思考一下。也许以后会再更新本蒟蒻的理解以及拓展。 参考资料T_Y_P_E的 【Codeforces 321E / BZOJ 5311】【DP凸优化】【单调队列】贞鱼 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 4010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;struct Node&#123; int l; int r; int v;&#125;Q[maxn];int n,m,f[maxn],cnt[maxn],sum[maxn][maxn];int Get(int j,int i)&#123; return f[j]+(sum[i][i]+sum[j][j]-sum[i][j]-sum[j][i])/2;&#125;int cmp(int v1,int v2,int n1,int n2)&#123; if(v1&lt;v2)return 1; if(v1&gt;v2)return -1; if(n1&lt;n2)return 1; if(n1&gt;n2)return -1; return 0;&#125;bool check(int v)&#123; int h=0,t=0; Q[t]=(Node)&#123;1,n,0&#125;; f[0]=0; for(int i=1;i&lt;=n;i++) &#123; while(h&lt;=t&amp;&amp;Q[h].r&lt;i)h+=1; int j=Q[h].v; cnt[i]=cnt[j]+1; f[i]=Get(j,i)+v; while(h&lt;=t&amp;&amp;cmp(Get(Q[t].v,Q[t].l),Get(i,Q[t].l),cnt[Q[t].v],cnt[i])==-1)t-=1; if(h&lt;=t) &#123; int l=Q[t].l,r=Q[t].r; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(cmp(Get(i,mid),Get(Q[t].v,mid),cnt[i],cnt[Q[t].v])==1)r=mid-1; else l=mid+1; &#125; Q[t].r=r; if(l&lt;=n)Q[++t]=(Node)&#123;l,n,i&#125;; &#125; else Q[++t]=(Node)&#123;i,n,i&#125;; &#125; return cnt[n]&lt;=m;&#125;int main()&#123; read(n,m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+read&lt;int&gt;(); int l=0,r=0x7fffffff; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid))r=mid-1; else l=mid+1; &#125; check(l); printf("%d\n",f[n]-l*m); return 0;&#125;]]></content>
      <tags>
        <tag>WQS二分</tag>
        <tag>DP</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4983 忘情]]></title>
    <url>%2F2019%2F04%2F27%2FP4983-%E5%BF%98%E6%83%85%2F</url>
    <content type="text"><![CDATA[P4983 忘情传送门洛谷 题目背景“为什么要离开我！” “因为你没玩儿转！” “我玩儿转了！” “那好，你现在就给我维护这么一个式子！” “为什么要出这么毒瘤的东西。” “为了恶心你。” “……” …………………………….……………………………. 题目描述你的 $npy$ 为了恶心你，特地请了四位大神和一个辣鸡！ $ \rm hdxriehdxrie$ 说：“我们得求和。”于是有了 $\sum \limits_{i=1}^n x_i $。 $\rm ImagineImagine$ 说：“我们得有平均数。”于是有了 $\bar x $。 $\rm TimeTravellerTimeTraveller$ 说：“我们得有加减乘除。”于是有了一些恶心的组合。 $\rm Althen·Way·SatanAlthen⋅Way⋅Satan$ 说：“我们还得有平方。”于是我们将它平方。 最垃圾的 $\rm ZredXNyZredXNy$ 说：“那我帮你们整合一下。” 于是，我们得到了这么一个式子 : \cfrac{\left((\sum\limits_{i=1}^{n}x_i\times \bar x)+\bar x\right)^2}{\bar x^2}我们定义一段序列的值为这个，其中 $n$为此序列的元素个数。 我们给定一段长度为 $n$ 的序列,现在要求将它分成 $m$ 段，要求每一段的值的总和最小，求出这个最小值。 输入输出格式输入格式：第一行两个正整数，分别为 $n$，$m$，定义见题面。 接下来一行为 $n$ 个正整数，依次给出这个序列的每个元素的值 $x_i$ 。 输出格式：一个整数，求出这个最小值。 输入输出样例输入样例#1：3 21 2 3 输出样例#1：32 输入样例#2：10 31 2 3 4 5 6 7 8 9 10 输出样例#2：1140 说明对于 $30 \% $ 的数据，$m \le n \le500$； 另有 $20 \% $ 的数据，保证 $m=2$； 对于 $100 \% $ 的数据，$m \le n \le 100000$，$1 \le x_i \le 1000$。 分析这种题先看看能不能化简式子。 \cfrac{\left((\sum\limits_{i=1}^{n}x_i \times \bar x)+\bar x\right)^2}{\bar x^2} \cfrac{\left(\bar x\sum\limits_{i=1}^{n}x_i + \bar x\right)^2}{\bar x^2} \cfrac{\bar x^2\left(\sum\limits_{i=1}^{n}x_i + 1\right)^2}{\bar x^2} \left(\sum\limits_{i=1}^{n}x_i+1 \right)^2嗯，斜率优化经典题。但有个$m$怎么办？上$WQS$二分。具体的然后考虑如何限制段数。感性地理解或者打表观察或者严格的数学证明可以发现：如果我们给每个$f_i$ 值都强行加上一个$val$，相当于是强行挂了一个重物上去，现在要最小化每个$f_i$ ，那么你挂的东西越重，为了最小化$f_i$而划分的总段数就会越少。 所以我们可以二分这个重物$val$，斜率优化做一遍$dp$，同时记录一下划分段数$cnt_i$，然后判断划分的总段数$cnt_n$与$m$的大小关系。如果$cnt_n&gt;m$就说明$val$不够大，要调大。(做法来自GKxx的题解） 参考资料$WQS$二分Creeper_LKF的 关于WQS二分算法以及其一个细节证明 本题题解GKxx的题解 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 100010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,m,Q[maxn],cnt[maxn];long long s[maxn],f[maxn];double calc(int a,int b)&#123; return (f[b]+s[b]*s[b]-2*s[b]-f[a]-s[a]*s[a]+2*s[a])/(2.*(s[b]-s[a]));&#125;bool check(long long v)&#123; int head=0,tail=0; for(int i=1;i&lt;=n;i++) &#123; while(head&lt;tail&amp;&amp;calc(Q[head],Q[head+1])&lt;=s[i])head+=1; f[i]=f[Q[head]]+(s[i]-s[Q[head]]+1)*(s[i]-s[Q[head]]+1)+v; cnt[i]=cnt[Q[head]]+1; while(head&lt;tail&amp;&amp;calc(Q[tail-1],Q[tail])&gt;=calc(Q[tail],i))tail-=1; Q[++tail]=i; &#125; return cnt[n]&gt;=m;&#125;int main()&#123; read(n,m); for(int i=1;i&lt;=n;i++)s[i]=s[i-1]+read&lt;int&gt;(); long long l=0,r=1e16; while(l&lt;=r) &#123; long long mid=(l+r)&gt;&gt;1; if(check(mid))l=mid+1; else r=mid-1; &#125; check(r); printf("%lld\n",f[n]-m*r); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>WQS二分</tag>
        <tag>DP</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2624 [HNOI2008]明明的烦恼]]></title>
    <url>%2F2019%2F04%2F24%2FP2624-HNOI2008-%E6%98%8E%E6%98%8E%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[P2624 [HNOI2008]明明的烦恼传送门洛谷 题目描述自从明明学了树的结构,就对奇怪的树产生了兴趣…… 给出标号为$1$到$N$的点,以及某些点最终的度数,允许在任意两点间连线,可产生多少棵度数满足要求的树? 输入输出格式输入格式：第一行为$N (0 &lt; N \le 1000)$,接下来$N$行,第$i+1$行给出第i个节点的度数$D_i$,如果对度数不要求,则输入$-1$ 输出格式：一个整数,表示不同的满足要求的树的个数,无解输出$0$ 输入输出样例输入样例#1：31-1-1 输出样例#1：2 说明两棵树分别为1-2-3 ; 1-3-2 分析前置知识：$Prufer$数列。众所周知，对于给定度数的无根树，共有$\cfrac{ (n-2)! }{ \prod_{i=1}^n (d_i-1)! }$情况。使用$Prufer$数列可以很方便的证明。但本题不是这么简单。首先考虑已知的条件，我们记$sum$为已知条件的和，$cnt$为已知条件个数。很显然，只考虑已知度数的点组成的无根树的情况，共有$\cfrac{ sum! }{ \prod_{i=1}^{cnt} (d_i-1)!}$种情况，直接套开头的式子。再考虑在总点数组成的$Prufer$数列中，由我们的已知点组成的$Prufer$子序列有多少种情况，显然，组合知识告诉我们，有$\dbinom{n-2}{sum}$种情况。在考虑剩下的位置，所以要乘上$(n-cnt)^{n-2-sum}$。化简一波： \frac{(n-2)!}{sum!(n-2-sum)!} \times \frac{ sum! }{ \prod_{i=1}^{cnt} (d_i-1)!} \times (n-cnt)^{n-2-sum} \\ \Rightarrow \frac{(n-2)!}{(n-2-sum)!\prod_{i=1}^{cnt} (d_i-1)!} \times (n-cnt)^{n-2-sum}发现一个很尴尬的问题，我们…似乎需要…高精度！！！高精乘还好说，高精除就比较尴尬了。弃疗其实还有一个办法，质因数分解。对于$n!$，如果$p$是一个质数，那么它的次数为 \left \lfloor \frac{n}{p^1} \right \rfloor + ... + \left \lfloor \frac{n}{p^x} \right \rfloor (p^x \le n)所以高精除就搞定了。至于高精乘，打板子。 参考资料$Prufer$数列自为风月马前卒的 prufer序列笔记xun的 prufer数列 本题题解本校巨佬autoint的题解TheLostWeak的题解JMJST的题解怡红公子的题解 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1010#define mod (int)1e6template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,cnt,sum,len=1,d[maxn],p[maxn],num[maxn],ans[maxn]=&#123;1&#125;;void init()&#123; for(int i=2;i&lt;=n;i++) &#123; if(!p[i])p[++p[0]]=i; for(int j=1;j&lt;=p[0]&amp;&amp;p[j]*i&lt;=n;j++) &#123; p[p[j]*i]=true; if(i%p[j]==0)break; &#125; &#125;&#125;void decomp(int n,int f)&#123; for(int i=1;i&lt;=p[0]&amp;&amp;p[i]&lt;=n;i++) for(int j=n;j&gt;=p[i];j/=p[i]) num[i]+=j/p[i]*f;&#125;void mul(int n)&#123; for(int i=0;i&lt;len;i++)ans[i]*=n; for(int i=0;i&lt;len;i++) if(ans[i]&gt;=mod) ans[i+1]+=ans[i]/mod,ans[i]%=mod; if(ans[len])len+=1;&#125;int main()&#123; n=read&lt;int&gt;(); init(); for(int i=1;i&lt;=n;i++) &#123; int tmp=read&lt;int&gt;(); if(tmp==-1)continue; cnt+=1; if(tmp&lt;=0||tmp&gt;n-2) &#123; puts("0"); return 0; &#125; sum+=tmp-1; d[++d[0]]=tmp; &#125; if(d[0]&gt;n-2) &#123; puts("0"); return 0; &#125; decomp(n-2,1); decomp(n-2-sum,-1); for(int i=1;i&lt;=d[0];i++)decomp(d[i]-1,-1); for(int i=1;i&lt;=p[0];i++) while(num[i]--) mul(p[i]); for(int i=1;i&lt;=n-2-sum;i++)mul(n-cnt); printf("%d",ans[len-1]); for(int i=len-2;i&gt;=0;i--)printf("%06d",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>高精度</tag>
        <tag>Prufer数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SP8093 JZPGYZ - Sevenk Love Oimaster]]></title>
    <url>%2F2019%2F04%2F24%2FSP8093-JZPGYZ-Sevenk-Love-Oimaster%2F</url>
    <content type="text"><![CDATA[SP8093 JZPGYZ - Sevenk Love Oimaster传送门洛谷 题意描述Oimaster and sevenk love each other.But recently,sevenk heard that a girl named ChuYuXun was dating with oimaster.As a woman’s nature, sevenk felt angry and began to check oimaster’s online talk with ChuYuXun. Oimaster talked with ChuYuXun n times, and each online talk actually is a string.Sevenk asks q questions like this, “how many strings in oimaster’s online talk contain this string as their substrings?题目大意：给定n个模板串，以及m个查询串，依次查询每一个查询串是多少个模板串的子串 输入输出格式输入格式：There are two integers in the first line, the number of strings n and the number of questions q. And n lines follow, each of them is a string describing oimaster’s online talk. And q lines follow, each of them is a question.n&lt;=10000, q&lt;=60000 the total length of n strings&lt;=100000, the total length of q question strings&lt;=360000 输出格式：For each question, output the answer in one line. 输入输出样例输入样例#1：3 3abcabcabcaaaaafeabcaca 输出样例#1：131 说明【样例解释1】$abc$在$abcabcabc$中出现了，所以第一个询问答案为1。 $a$在三个字符串中都出现了，所以第二个询问答案为3。 $ca$只在$abcabcabc$中出现了，所以第三个询问的答案为1。 分析这是一道广义$SAM$模板题。本来想打一打来练手，但似乎出了锅。具体的说：我打了一份枚举子串更新$SAM$的代码，过了。忽然想起，似乎还可以在插入时更新$SAM$，打了以后，挂了。不知道是根本不能这样做还是我哪里打挂了，请大佬帮忙查一下错，谢谢！ 代码插入时更新$SAM$然后挂了的代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 100010#define maxm 360010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,m,las,cnt=1,fa[maxn&lt;&lt;1],vis[maxn&lt;&lt;1],len[maxn&lt;&lt;1],val[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26];char str[maxm];void add(int cc,int pos)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][cc];p=fa[p])ch[p][cc]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][cc]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; len[nq]=len[p]+1; fa[nq]=fa[q]; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][cc]==q;p=fa[p])ch[p][cc]=nq; &#125; &#125; for(;np&amp;&amp;vis[np]!=pos;np=fa[np]) vis[np]=pos,val[np]+=1;&#125;int main()&#123; read(n,m); for(int i=1;i&lt;=n;i++) &#123; las=1; scanf("%s",str); int len=strlen(str); for(int j=0;j&lt;len;j++) add(str[j]-'a',i); &#125; for(int i=1;i&lt;=m;i++) &#123; int now=1,flag=true; scanf("%s",str); int len=strlen(str); for(int j=0;j&lt;len;j++) &#123; if(!ch[now][str[j]-'a']) &#123; flag=false; puts("0"); break; &#125; now=ch[now][str[j]-'a']; &#125; if(flag)printf("%d\n",val[now]); &#125; return 0;&#125; 枚举子串更新的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 100010#define maxm 10010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,m,las,cnt=1,fa[maxn&lt;&lt;1],vis[maxn&lt;&lt;1],len[maxn&lt;&lt;1],val[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26];string str[maxm];void add(int cc)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][cc];p=fa[p])ch[p][cc]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][cc]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; len[nq]=len[p]+1; fa[nq]=fa[q]; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][cc]==q;p=fa[p])ch[p][cc]=nq; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; las=1; cin&gt;&gt;str[i]; for(int j=0;j&lt;(int)str[i].length();j++) add(str[i][j]-'a'); &#125; for(int i=1;i&lt;=n;i++) &#123; int now=1; for(int j=0;j&lt;(int)str[i].length();j++) &#123; now=ch[now][str[i][j]-'a']; int tmp=now; while(tmp&amp;&amp;vis[tmp]!=i) &#123; vis[tmp]=i; val[tmp]+=1; tmp=fa[tmp]; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; int now=1,flag=true; cin&gt;&gt;str[0]; for(int j=0;j&lt;(int)str[0].length();j++) &#123; if(!ch[now][str[0][j]-'a']) &#123; flag=false; puts("0"); break; &#125; now=ch[now][str[0][j]-'a']; &#125; if(flag)printf("%d\n",val[now]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-4-24课件]]></title>
    <url>%2F2019%2F04%2F23%2F2019-4-24%E8%AF%BE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>课件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3277 串]]></title>
    <url>%2F2019%2F04%2F23%2FBZOJ3277-%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[BZOJ3277 串传送门BZOJ 题目描述字符串是oi界常考的问题。现在给定你$n$个字符串，询问每个字符串有多少子串（不包括空串）是所有$n$个字符串中至少$k$个字符串的子串（注意包括本身）。 输入输出格式输入格式：第一行两个整数$n$，$k$。接下来$n$行每行一个字符串。$n,k,l \le 100000$ 输出格式：输出一行$n$个整数，第$i$个整数表示第$i$个字符串的答案。 输入输出样例输入样例：3 1abcaab 输出样例：6 1 3 分析广义$SAM$模板题(应该是)。不知道为什么，用了快读读数字，再用cin读string就爆炸了。 参考资料广义$SAM$dwjshift的 用SAM建广义后缀树 提供在线和离线建法。话说这篇资料里提到的不在Trie上建$SAM$是怎么做的？？？wangzhen_yu的 广义后缀自动机 提供很好的例题及代码讲解。以前不懂什么叫进行内容更新，菜啊phile的 关于广义后缀树（多串SAM）的总结 本题自为风月马前卒的题解 主要参考题解，这篇题解是枚举前缀的后缀(即子串)进行内容更新，而不是插入时更新，换句话说，这篇题解是从上至下更新，而不是一般的插入时从下至上更新。clover_hxy的 题解 这篇题解是在建自动机的时候统计的每个状态的出现次数，最后求答案时连边跳，不过没看懂其中的mark数组是干什么的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 100010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,m,las,cnt=1,times[maxn&lt;&lt;1],sum[maxn&lt;&lt;1],vis[maxn&lt;&lt;1],len[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26];string str[maxn];void add(int cc)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][cc];p=fa[p])ch[p][cc]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][cc]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; fa[nq]=fa[q]; len[nq]=len[p]+1; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][cc]==q;p=fa[p])ch[p][cc]=nq; &#125; &#125;&#125;void dfs(int x)&#123; if(!x||vis[x])return ; vis[x]=true; dfs(fa[x]); sum[x]+=sum[fa[x]];&#125;void GetTimes()&#123; for(int i=1;i&lt;=n;i++) &#123; int now=1; for(int j=0;j&lt;(int)str[i].length();j++) &#123; now=ch[now][str[i][j]-'a']; int tmp=now; while(tmp&amp;&amp;vis[tmp]!=i) &#123; vis[tmp]=i; times[tmp]+=1; tmp=fa[tmp]; &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; las=1; cin&gt;&gt;str[i]; for(int j=0;j&lt;(int)str[i].length();j++)add(str[i][j]-'a'); &#125; GetTimes(); for(int i=1;i&lt;=cnt;i++)sum[i]=(times[i]&gt;=m)*(len[i]-len[fa[i]]); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=cnt;i++)dfs(i); for(int i=1;i&lt;=n;i++) &#123; int ans=0,now=1; for(int j=0;j&lt;(int)str[i].length();j++) now=ch[now][str[i][j]-'a'],ans+=sum[now]; printf("%d ",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4022 [CTSC2012]熟悉的文章]]></title>
    <url>%2F2019%2F04%2F21%2FP4022-CTSC2012-%E7%86%9F%E6%82%89%E7%9A%84%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[P4022 [CTSC2012]熟悉的文章传送门洛谷 题目描述阿米巴是小强的好朋友。 在小强眼中，阿米巴是一个作文成绩很高的文艺青年。为了获取考试作文的真谛，小强向阿米巴求教。阿米巴给小强展示了几篇作文，小强觉得这些文章怎么看怎么觉得熟悉，仿佛是某些范文拼拼凑凑而成的。小强不禁向阿米巴投去了疑惑的眼光，却发现阿米巴露出了一个狡黠的微笑。 为了有说服力地向阿米巴展示阿米巴的作文是多么让人觉得“眼熟”，小强想出了一个评定作文 “熟悉程度”的量化指标：L 0 .小强首先将作文转化成一个 01 串。之后，小强搜集了各路名家的文章，同样分别转化成 01 串后，整理出一个包含了 M 个 01 串的“ 标准作文库 ”。 小强认为：如果一个 01 串长度不少于 L 且在 标准作文库 中的某个串里出现过（即，它是 标准作文库 的 某个串 的一个 连续子串 ），那么它是“ 熟悉 ”的。对于一篇作文（一个 01 串）A，如果能够把 A 分割成若干段子串，其中“ 熟悉 ” 的子串的 长度 总 和 不少于 A 总 长度的 90%，那么称 A 是 “ 熟悉的文章 ”。 L 0 是 能够让 A 成为 “ 熟悉的文章 ” 的 所有 L 的最大值 （如果不存在这样的 L，那么规定 L 0 =0）。 举个例子： 小强的作文库里包含了如下 2 个字符串： 10110000001110有一篇待考察的作文是： 1011001100小强计算出这篇作文 L 的最大值是 4，因为待考察的作文可以视作’10110’+’0110’+’0’，其中’10110’和’0110’被判定为 “ 熟悉 ” 的。而当 L = 5 或是更大的时候，不存在符合题意的分割方法。所以，这篇作文的 L 0 = 4。小强认为阿米巴作文的 L 0 值比其他同学的明显要大。请你帮他验证一下。 输入输出格式输入格式：输入文件 cheat.in 第一行是两个整数 N, M，表示待检查的作文数量，和小强的标准作文库的行数。 接下来是 M 行的 01 串，表示标准作文库。 接下来是 N 行的 01 串，表示 N 篇作文。 输出格式：输出文件 cheat.out 包含 N 行，每一行包含一个整数，表示该篇作文的 L 0 值。 输入输出样例输入样例#1：1 2101100000011101011001100 输出样例#1：4 说明对于 30%的测试数据，输入文件的长度不超过 1000 字节。 对于 50%的测试数据，输入文件的长度不超过 61000 字节。 对于 80%的测试数据，输入文件的长度不超过 250000 字节。 对于 100%的测试数据，输入文件的长度不超过 1100000 字节。 分析$0pts：$不打或打炸。看到求最小的最大值，想到二分。证明一波：很明显，对于大的可行的串，它的小的子串一定也可行(即，对于一个可行的L,小于它的L一定也可行)，反之不一定成立，满足单调性，所以可以二分。那么怎么$check$呢？？？想到DP。我们设$f_i$表示以$i$位置结尾时题意要求的最大值。很容易写出转移方程如下： f_j=max(f_i-1,f_j+i-(j+1)+1),j \in [i-len_i,i-L]其中，$len_i$表示符合题意要求的分割的最大值，即以$i$结尾的可以被匹配的01串的最大值。直接搞，$60pts$到手。但转念想想，正解(如果也是用这个DP方程的话)不可能直接暴力转移，不然就满分了，不会才$60pts$。如果想要通过本题的话，复杂度应该是在$O(nlogn)$左右。那么转移应该做到$O(1)$才行。想想把$O(n)$的DP转移优化为$O(1)$的方法就那么几种。再发现两个边界($i-len_i$,$i-L$)中第一个边界肯定是单调不降的，第二个边界是单调上升的，很容易理解和证明，这里省去证明。于是想到单调队列优化DP。稍微化一下式子就行了。DP处理完了。想一想$len_i$怎么求，发现这个东西在广义$SAM$上跑一下就行了。另外，在打代码的时候注意一下循环语句的执行顺序，我就在把while改for的时候爆炸了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1000010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,m,sl,cnt=1,las,Q[maxn],f[maxn],match[maxn],len[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][2];char str[maxn];void add(int cc)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][cc];p=fa[p])ch[p][cc]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][cc]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; len[nq]=len[p]+1; fa[nq]=fa[q]; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][cc]==q;p=fa[p])ch[p][cc]=nq; &#125; &#125;&#125;void Match()&#123; int p=1,l=0,c; for(int i=1;i&lt;=sl;i++) &#123; c=str[i]-'0'; if(ch[p][c])p=ch[p][c],l+=1; else &#123; for(;p&amp;&amp;!ch[p][c];p=fa[p]); if(p)l=len[p]+1,p=ch[p][c]; else p=1,l=0; &#125; match[i]=l; &#125;&#125;bool check(int L)&#123; int h=1,t=0; for(int i=1;i&lt;=L-1;i++)f[i]=0; for(int i=L;i&lt;=sl;i++) &#123; f[i]=f[i-1]; while(h&lt;=t&amp;&amp;f[Q[t]]-Q[t]&lt;f[i-L]-(i-L))t-=1; Q[++t]=i-L; while(h&lt;=t&amp;&amp;Q[h]&lt;i-match[i])h+=1; if(h&lt;=t)f[i]=max(f[i],f[Q[h]]+i-Q[h]); &#125; return f[sl]*10&gt;=sl*9;&#125;int main()&#123; read(n,m); for(int i=1;i&lt;=m;i++) &#123; las=1; scanf("%s",str+1); sl=strlen(str+1); for(int j=1;j&lt;=sl;j++)add(str[j]-'0'); &#125; for(int tot=1;tot&lt;=n;tot++) &#123; scanf("%s",str+1); sl=strlen(str+1); Match(); int l=0,r=sl,ans=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid))ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>CTSC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3649 [APIO2014]回文串]]></title>
    <url>%2F2019%2F04%2F21%2FP3649-APIO2014-%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[P3649 [APIO2014]回文串传送门洛谷 题目描述给你一个由小写拉丁字母组成的字符串 $s$。我们定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。 对于给你的这个字符串 $s$，求所有回文子串中的最大存在值。 输入输出格式输入格式：一行，一个由小写拉丁字母（a~z）组成的非空字符串 $s$。 输出格式：输出一个整数，表示所有回文子串中的最大存在值。 输入输出样例输入样例#1：abacaba 输出样例#1：7 输入样例#2：www 输出样例#2：4 说明【样例解释1】用 $\lvert s \rvert$ 表示字符串 s 的长度。 一个字符串 $s_1 s_2 \dots s_{\lvert s \rvert}$的子串是一个非空字符串 $s_i s_{i+1} \dots s_j$，其中 $1 \leq i \leq j \leq \lvert s \rvert$。每个字符串都是自己的子串。 一个字符串被称作回文串当且仅当这个字符串从左往右读和从右往左读都是相同的。 这个样例中，有 $7$ 个回文子串 a，b，c，aba，aca，bacab，abacaba。他们的存在值分别为 $4, 2, 1, 6, 3, 5, 7$。 所以回文子串中最大的存在值为 $7$。 第一个子任务共 8 分，满足 $1 \leq \lvert s \rvert \leq 100$。 第二个子任务共 15 分，满足 $1 \leq \lvert s \rvert \leq 1000$。 第三个子任务共 24 分，满足 $1 \leq \lvert s \rvert \leq 10000$。 第四个子任务共 26 分，满足 $1 \leq \lvert s \rvert \leq 100000$。 第五个子任务共 27 分，满足 $1 \leq \lvert s \rvert \leq 300000$。 分析看到“定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度“,第一反应这不是P3804的定义吗。于是…嗯…$SAM$！！！其实是因为我是搜$SAM$的标签搜到的这题嗯…打一发…哦~过了样例。开心ing…交一发….等等！开不开long long。算一波极限,赋值一下,编译器告诉我—-overflow in implicit constant conversion。哦~看来要开long long。交一发….额~50分？？？为什么只有50分？？？我的$SAM$打错了？？？懵逼ing…哦~回文串嘛。为什么直接求所有子串的存在值有50分？？？可是回文串怎么做？？？题解….$SAM$套$Manacher$加倍增？？？好麻烦不打，复杂度还是$O(nlogn)$的，还被卡空间….嗯~纯$SAM$的，可是…图呢？？？没图我怎么知道你在说什么？？？网上一搜…又搜到一篇…还是没图(确切的说，是当时没图)…放弃…颓废ing…算了，回文自动机正等着我…学习ing…发现我的回文自动机没初始化特殊字符？？？(即$s_0=-1$)，还是过了？？？算了，不再交了，放代码的时候加上算了。 参考资料纯$SAM$Leaves的题解asuldb的题解 回文自动机大奕哥&amp;VANE的 Palindromic Tree 回文自动机-回文树 例题+讲解 主要学习资料Clove_unique的 Manacher 回文自动机 学习笔记 主要是为了看图冯钰恒的 回文树/回文自动机/PAM总结——题解 P3649 【[APIO2014]回文串】 主要参考代码实现F.W.Nietzsche的 回文树或者回文自动机，及相关例题KSKUN的 回文自动机原理与实现 Updateasuldb的题解刷新一波又有图了，于是再学…为什么我做的时候你没图，做完就有图了！！！ 代码第一份傻逼的错误代码写了这么久好歹还是放一下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 300010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,las=1,cnt=1,ton[maxn&lt;&lt;1],ns[maxn&lt;&lt;1],len[maxn&lt;&lt;1],siz[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26];long long ans;char str[maxn];void add(int c)&#123; int p=las,np=las=++cnt; siz[np]=1; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][c];p=fa[p])ch[p][c]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; fa[nq]=fa[q]; len[nq]=len[p]+1; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][c]==q;p=fa[p])ch[p][c]=nq; &#125; &#125;&#125;int main()&#123; scanf("%s",str);n=strlen(str); for(int i=0;i&lt;n;i++)add(str[i]-'a'); for(int i=1;i&lt;=cnt;i++)ton[len[i]]+=1; for(int i=1;i&lt;=cnt;i++)ton[i]+=ton[i-1]; for(int i=1;i&lt;=cnt;i++)ns[ton[len[i]]--]=i; for(int i=cnt;i&gt;=1;i--) &#123; siz[fa[ns[i]]]+=siz[ns[i]]; ans=max(ans,1ll*len[ns[i]]*siz[ns[i]]); &#125; printf("%lld\n",ans); return 0;&#125; 回文自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define maxn 300010using namespace std;template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,cnt,last,pos,s[maxn],fail[maxn],len[maxn],Count[maxn],ch[maxn][26];long long ans;char str[maxn];void Init()&#123; len[0]=0; len[1]=-1; fail[0]=1; s[0]=-1; //之前交的时候没加这个，现在补上 cnt=1; last=0;&#125;int Get(int k)&#123; while(s[pos]!=s[pos-len[k]-1])k=fail[k]; return k;&#125;void add(int cc)&#123; s[++pos]=cc; int x=Get(last); if(!ch[x][cc]) &#123; int y=++cnt; len[y]=len[x]+2; fail[y]=ch[Get(fail[x])][cc]; ch[x][cc]=y; &#125; last=ch[x][cc]; Count[last]+=1;&#125;int main()&#123; scanf("%s",str); n=strlen(str); Init(); for(int i=0;i&lt;n;i++)add(str[i]-'a'); for(int i=cnt;i&gt;1;i--) &#123; Count[fail[i]]+=Count[i]; ans=max(ans,1ll*Count[i]*len[i]); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>APIO</tag>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3975 [TJOI2015]弦论]]></title>
    <url>%2F2019%2F04%2F18%2FP3975-TJOI2015-%E5%BC%A6%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[P3975 [TJOI2015]弦论传送门洛谷 题目描述为了提高智商,ZJY开始学习弦论。这一天,她在《 String theory》中看到了这样一道问题:对于一个给定的长度为n的字符串,求出它的第k小子串是什么。你能帮帮她吗? 输入输出格式输入格式：第一行是一个仅由小写英文字母构成的字符串s 第二行为两个整数t和k,t为0则表示不同位置的相同子串算作一个,t为1则表示不同位置的相同子串算作多个。k的意义见题目描述。 输出格式：输出数据仅有一行,该行有一个字符串,为第k小的子串。若子串数目不足k个,则输出-1。 输入输出样例输入样例#1：aabc0 3 输出样例#1：aab 输入样例#2：aabc1 3 输出样例#2：aa 输入样例#3：aabc1 11 输出样例#3：-1 说明数据范围对于$10\%$的数据，$n \le 1000$。 对于$50\%$的数据，$t = 0$。 对于$100\%$的数据，$n \le 5 × 10^5, t &lt; 2, k \le 10^9$。 分析T=0时，设$siz_i=1$，即出现次数设为1。T=1时，将$siz_i$设为$Endpos$的大小，即出现次数。 之前在想如果复制的点不设置$siz_i$，最终统计时是否会出现$siz_i=0$的情况。网上说不会。那就自己yy一下。因为复制的点一定有子树，而$siz_i$是子树中终止节点的个数。那么我们就需要就证明子树中一定有至少一个终止节点。因为它有子树，说明有终止节点(感觉像没证一样，但换个角度想想，我们又不傻，如果它的子树内没有终止节点，那么我们还建子树干嘛，只会平白浪费时间和空间)。所以得证。正确性不保证，自己什么都不懂，没有理论支持，自己yy自然没法保证正确性…如果有人发现这个假了，或者有正确性保证的证明，请评论告诉我，谢谢。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 500010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int T,k,las=1,cnt=1,siz[maxn&lt;&lt;1],sum[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26],len[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],tong[maxn&lt;&lt;1],ns[maxn&lt;&lt;1];char str[maxn];void add(int c)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; siz[cnt]=1; while(p&amp;&amp;!ch[p][c])ch[p][c]=np,p=fa[p]; if(!p)fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[nq]=fa[q]; len[nq]=len[p]+1; fa[q]=fa[np]=nq; while(p&amp;&amp;ch[p][c]==q)ch[p][c]=nq,p=fa[p]; &#125; &#125;&#125;void pre()&#123; for(int i=1;i&lt;=cnt;i++)tong[len[i]]++; for(int i=1;i&lt;=cnt;i++)tong[i]+=tong[i-1]; for(int i=1;i&lt;=cnt;i++)ns[tong[len[i]]--]=i; for(int i=cnt;i&gt;=1;i--) if(T)siz[fa[ns[i]]]+=siz[ns[i]]; else siz[i]=1; siz[1]=0; for(int i=cnt;i&gt;=1;i--) &#123; sum[ns[i]]=siz[ns[i]]; for(int j=0;j&lt;26;j++) if(ch[ns[i]][j]) sum[ns[i]]+=sum[ch[ns[i]][j]]; &#125;&#125;void solve()&#123; if(k&gt;sum[1]) &#123; puts("-1"); return ; &#125; int now=1; k-=siz[now]; while(k) &#123; int i=0; while(k&gt;sum[ch[now][i]]) k-=sum[ch[now][i]],i+=1; now=ch[now][i]; putchar('a'+i); k-=siz[now]; &#125;&#125;int main()&#123; scanf("%s",str); read(T,k); int len=strlen(str); for(int i=0;i&lt;len;i++)add(str[i]-'a'); pre(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3804 后缀自动机]]></title>
    <url>%2F2019%2F04%2F17%2FP3804-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[P3804 后缀自动机传送门洛谷 题目描述给定一个只包含小写字母的字符串$S$, 请你求出 $S$ 的所有出现次数不为 1 的子串的出现次数乘上该子串长度的最大值。 输入输出格式输入格式：一行一个仅包含小写字母的字符串$S$ 输出格式：一个整数，为 所求答案 输入输出样例输入样例#1：abab 输出样例#1：4 说明对于$10\%$的数据，$\lvert S \rvert \le 1000$对于$100\%$的数据，$\lvert S \rvert \le 10^6$ 分析既然是后缀自动机模板，自然用后缀自动机来做，具体的，就是建立后缀自动机，然后再Parent树上DFS，答案为子树大小*节点的len长度的最大值。 Update：以前没能弄清为什么siz[…]=1写在建后缀自动机里就行，写在DFS里就挂，后来Achen告诉我有些点没有siz值。 后缀自动机入门 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1000010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;struct Node&#123; int fa; int len; int ch[30];&#125;node[maxn&lt;&lt;1];struct Edge&#123; int v; Edge *next; Edge(int a=0,Edge *b=NULL) &#123; v=a; next=b; &#125;&#125;*head[maxn&lt;&lt;1];int len,tot=1,las=1;long long ans,siz[maxn&lt;&lt;1];char str[maxn];void add(int c)&#123; int p=las,np=las=++tot; siz[tot]=1; node[np].len=node[p].len+1; for(;p&amp;&amp;!node[p].ch[c];p=node[p].fa)node[p].ch[c]=np; if(!p)node[np].fa=1; else &#123; int q=node[p].ch[c]; if(node[q].len==node[p].len+1)node[np].fa=q; else &#123; int nq=++tot; node[nq]=node[q]; node[nq].len=node[p].len+1; node[q].fa=node[np].fa=nq; for(;p&amp;&amp;node[p].ch[c]==q;p=node[p].fa)node[p].ch[c]=nq; &#125; &#125;&#125;void dfs(int k)&#123; for(Edge *i=head[k];i!=NULL;i=i-&gt;next) &#123; dfs(i-&gt;v); siz[k]+=siz[i-&gt;v]; &#125; if(siz[k]!=1)ans=max(ans,siz[k]*node[k].len);&#125;int main()&#123; scanf("%s",str); len=strlen(str); for(int i=0;i&lt;len;i++)add(str[i]-'a'); for(int i=2;i&lt;=tot;i++)head[node[i].fa]=new Edge(i,head[node[i].fa]); dfs(1); printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>模板</tag>
      </tags>
  </entry>
</search>
