<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[P3649 [APIO2014]回文串]]></title>
    <url>%2F2019%2F04%2F21%2FP3649-APIO2014-%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[P3649 [APIO2014]回文串传送门洛谷 题目描述给你一个由小写拉丁字母组成的字符串 $s$。我们定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。 对于给你的这个字符串 $s$，求所有回文子串中的最大存在值。 输入输出格式输入格式：一行，一个由小写拉丁字母（a~z）组成的非空字符串 $s$。 输出格式：输出一个整数，表示所有回文子串中的最大存在值。 输入输出样例输入样例#1：abacaba 输出样例#1：7 输入样例#2：www 输出样例#2：4 说明【样例解释1】用 $\lvert s \rvert$ 表示字符串 s 的长度。 一个字符串 $s_1 s_2 \dots s_{\lvert s \rvert}$的子串是一个非空字符串 $s_i s_{i+1} \dots s_j$，其中 $1 \leq i \leq j \leq \lvert s \rvert$。每个字符串都是自己的子串。 一个字符串被称作回文串当且仅当这个字符串从左往右读和从右往左读都是相同的。 这个样例中，有 $7$ 个回文子串 a，b，c，aba，aca，bacab，abacaba。他们的存在值分别为 $4, 2, 1, 6, 3, 5, 7$。 所以回文子串中最大的存在值为 $7$。 第一个子任务共 8 分，满足 $1 \leq \lvert s \rvert \leq 100$。 第二个子任务共 15 分，满足 $1 \leq \lvert s \rvert \leq 1000$。 第三个子任务共 24 分，满足 $1 \leq \lvert s \rvert \leq 10000$。 第四个子任务共 26 分，满足 $1 \leq \lvert s \rvert \leq 100000$。 第五个子任务共 27 分，满足 $1 \leq \lvert s \rvert \leq 300000$。 分析看到“定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度“,第一反应这不是P3804的定义吗。于是…嗯…$SAM$！！！其实是因为我是搜$SAM$的标签搜到的这题嗯…打一发…哦~过了样例。开心ing…交一发….等等！开不开long long。算一波极限,赋值一下,编译器告诉我—-overflow in implicit constant conversion。哦~看来要开long long。交一发….额~50分？？？为什么只有50分？？？我的$SAM$打错了？？？懵逼ing…哦~回文串嘛。为什么直接求所有子串的存在值有50分？？？可是回文串怎么做？？？题解….$SAM$套$Manacher$加倍增？？？好麻烦不打，复杂度还是$O(nlogn)$的，还被卡空间….嗯~纯$SAM$的，可是…图呢？？？没图我怎么知道你在说什么？？？网上一搜…又搜到一篇…还是没图(确切的说，是当时没图)…放弃…颓废ing…算了，回文自动机正等着我…学习ing…发现我的回文自动机没初始化特殊字符？？？(即$s_0=-1$)，还是过了？？？算了，不再交了，放代码的时候加上算了。 参考资料纯$SAM$Leaves的题解asuldb的题解 回文自动机大奕哥&amp;VANE的 Palindromic Tree 回文自动机-回文树 例题+讲解 主要学习资料Clove_unique的 Manacher 回文自动机 学习笔记 主要是为了看图冯钰恒的 回文树/回文自动机/PAM总结——题解 P3649 【[APIO2014]回文串】 主要参考代码实现 Updateasuldb的题解刷新一波又有图了，于是再学…为什么我做的时候你没图，做完就有图了！！！ 代码第一份傻逼的错误代码写了这么久好歹还是放一下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 300010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,las=1,cnt=1,ton[maxn&lt;&lt;1],ns[maxn&lt;&lt;1],len[maxn&lt;&lt;1],siz[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26];long long ans;char str[maxn];void add(int c)&#123; int p=las,np=las=++cnt; siz[np]=1; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][c];p=fa[p])ch[p][c]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; fa[nq]=fa[q]; len[nq]=len[p]+1; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][c]==q;p=fa[p])ch[p][c]=nq; &#125; &#125;&#125;int main()&#123; scanf("%s",str);n=strlen(str); for(int i=0;i&lt;n;i++)add(str[i]-'a'); for(int i=1;i&lt;=cnt;i++)ton[len[i]]+=1; for(int i=1;i&lt;=cnt;i++)ton[i]+=ton[i-1]; for(int i=1;i&lt;=cnt;i++)ns[ton[len[i]]--]=i; for(int i=cnt;i&gt;=1;i--) &#123; siz[fa[ns[i]]]+=siz[ns[i]]; ans=max(ans,1ll*len[ns[i]]*siz[ns[i]]); &#125; printf("%lld\n",ans); return 0;&#125; 回文自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define maxn 300010using namespace std;template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,cnt,last,pos,s[maxn],fail[maxn],len[maxn],Count[maxn],ch[maxn][26];long long ans;char str[maxn];void Init()&#123; len[0]=0; len[1]=-1; fail[0]=1; s[0]=-1; //之前交的时候没加这个，现在补上 cnt=1; last=0;&#125;int Get(int k)&#123; while(s[pos]!=s[pos-len[k]-1])k=fail[k]; return k;&#125;void add(int cc)&#123; s[++pos]=cc; int x=Get(last); if(!ch[x][cc]) &#123; int y=++cnt; len[y]=len[x]+2; fail[y]=ch[Get(fail[x])][cc]; ch[x][cc]=y; &#125; last=ch[x][cc]; Count[last]+=1;&#125;int main()&#123; scanf("%s",str); n=strlen(str); Init(); for(int i=0;i&lt;n;i++)add(str[i]-'a'); for(int i=cnt;i&gt;1;i--) &#123; Count[fail[i]]+=Count[i]; ans=max(ans,1ll*Count[i]*len[i]); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>APIO</tag>
        <tag>模板</tag>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3975 [TJOI2015]弦论]]></title>
    <url>%2F2019%2F04%2F18%2FP3975-TJOI2015-%E5%BC%A6%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[P3975 [TJOI2015]弦论传送门洛谷 题目描述为了提高智商,ZJY开始学习弦论。这一天,她在《 String theory》中看到了这样一道问题:对于一个给定的长度为n的字符串,求出它的第k小子串是什么。你能帮帮她吗? 输入输出格式输入格式：第一行是一个仅由小写英文字母构成的字符串s 第二行为两个整数t和k,t为0则表示不同位置的相同子串算作一个,t为1则表示不同位置的相同子串算作多个。k的意义见题目描述。 输出格式：输出数据仅有一行,该行有一个字符串,为第k小的子串。若子串数目不足k个,则输出-1。 输入输出样例输入样例#1：aabc0 3 输出样例#1：aab 输入样例#2：aabc1 3 输出样例#2：aa 输入样例#3：aabc1 11 输出样例#3：-1 说明数据范围对于$10\%$的数据，$n \le 1000$。 对于$50\%$的数据，$t = 0$。 对于$100\%$的数据，$n \le 5 × 10^5, t &lt; 2, k \le 10^9$。 分析T=0时，设$siz_i=1$，即出现次数设为1。T=1时，将$siz_1$设为$Endpos$的大小，即出现次数。 之前在想如果复制的点不设置$siz_i$，最终统计时是否会出现$siz_i=0$的情况。网上说不会。那就自己yy一下。因为复制的点一定有子树，而$siz_i$是子树中终止节点的个数。那么我们就需要就证明子树中一定有至少一个终止节点。因为它有子树，说明有终止节点(感觉像没证一样，但换个角度想想，我们又不傻，如果它的子树内没有终止节点，那么我们还建子树干嘛，只会平白浪费时间和空间)。所以得证。正确性不保证，自己什么都不懂，没有理论支持，自己yy自然没法保证正确性…如果有人发现这个假了，或者有正确性保证的证明，请评论告诉我，谢谢。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 500010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int T,k,las=1,cnt=1,siz[maxn&lt;&lt;1],sum[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26],len[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],tong[maxn&lt;&lt;1],ns[maxn&lt;&lt;1];char str[maxn];void add(int c)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; siz[cnt]=1; while(p&amp;&amp;!ch[p][c])ch[p][c]=np,p=fa[p]; if(!p)fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[nq]=fa[q]; len[nq]=len[p]+1; fa[q]=fa[np]=nq; while(p&amp;&amp;ch[p][c]==q)ch[p][c]=nq,p=fa[p]; &#125; &#125;&#125;void pre()&#123; for(int i=1;i&lt;=cnt;i++)tong[len[i]]++; for(int i=1;i&lt;=cnt;i++)tong[i]+=tong[i-1]; for(int i=1;i&lt;=cnt;i++)ns[tong[len[i]]--]=i; for(int i=cnt;i&gt;=1;i--) if(T)siz[fa[ns[i]]]+=siz[ns[i]]; else siz[i]=1; siz[1]=0; for(int i=cnt;i&gt;=1;i--) &#123; sum[ns[i]]=siz[ns[i]]; for(int j=0;j&lt;26;j++) if(ch[ns[i]][j]) sum[ns[i]]+=sum[ch[ns[i]][j]]; &#125;&#125;void solve()&#123; if(k&gt;sum[1]) &#123; puts("-1"); return ; &#125; int now=1; k-=siz[now]; while(k) &#123; int i=0; while(k&gt;sum[ch[now][i]]) k-=sum[ch[now][i]],i+=1; now=ch[now][i]; putchar('a'+i); k-=siz[now]; &#125;&#125;int main()&#123; scanf("%s",str); read(T,k); int len=strlen(str); for(int i=0;i&lt;len;i++)add(str[i]-'a'); pre(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3804 后缀自动机]]></title>
    <url>%2F2019%2F04%2F17%2FP3804-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[P3804 后缀自动机传送门洛谷 题目描述给定一个只包含小写字母的字符串$S$, 请你求出 $S$ 的所有出现次数不为 1 的子串的出现次数乘上该子串长度的最大值。 输入输出格式输入格式：一行一个仅包含小写字母的字符串$S$ 输出格式：一个整数，为 所求答案 输入输出样例输入样例#1：abab 输出样例#1：4 说明对于$10\%$的数据，$\lvert S \rvert \le 1000$对于$100\%$的数据，$\lvert S \rvert \le 10^6$ 分析既然是后缀自动机模板，自然用后缀自动机来做，具体的，就是建立后缀自动机，然后再Parent树上DFS，答案为子树大小*节点的len长度的最大值。 没能弄清为什么siz[…]=1写在建后缀自动机里就行，写在DFS里就挂？？？ Achen告诉我有些点没有siz值。 &nbsp;后缀自动机入门 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1000010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;struct Node&#123; int fa; int len; int ch[30];&#125;node[maxn&lt;&lt;1];struct Edge&#123; int v; Edge *next; Edge(int a=0,Edge *b=NULL) &#123; v=a; next=b; &#125;&#125;*head[maxn&lt;&lt;1];int len,tot=1,las=1;long long ans,siz[maxn&lt;&lt;1];char str[maxn];void add(int c)&#123; int p=las,np=las=++tot; siz[tot]=1; node[np].len=node[p].len+1; for(;p&amp;&amp;!node[p].ch[c];p=node[p].fa)node[p].ch[c]=np; if(!p)node[np].fa=1; else &#123; int q=node[p].ch[c]; if(node[q].len==node[p].len+1)node[np].fa=q; else &#123; int nq=++tot; node[nq]=node[q]; node[nq].len=node[p].len+1; node[q].fa=node[np].fa=nq; for(;p&amp;&amp;node[p].ch[c]==q;p=node[p].fa)node[p].ch[c]=nq; &#125; &#125;&#125;void dfs(int k)&#123; for(Edge *i=head[k];i!=NULL;i=i-&gt;next) &#123; dfs(i-&gt;v); siz[k]+=siz[i-&gt;v]; &#125; if(siz[k]!=1)ans=max(ans,siz[k]*node[k].len);&#125;int main()&#123; scanf("%s",str); len=strlen(str); for(int i=0;i&lt;len;i++)add(str[i]-'a'); for(int i=2;i&lt;=tot;i++)head[node[i].fa]=new Edge(i,head[node[i].fa]); dfs(1); printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
</search>
