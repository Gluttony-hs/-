<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BZOJ3277 串]]></title>
    <url>%2F2019%2F04%2F23%2FBZOJ3277-%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[BZOJ3277 串传送门BZOJ 题目描述字符串是oi界常考的问题。现在给定你$n$个字符串，询问每个字符串有多少子串（不包括空串）是所有n个字符串中至少$k$个字符串的子串（注意包括本身）。 输入输出格式输入格式：第一行两个整数$n$，$k$。接下来$n$行每行一个字符串。$n,k,l \le 100000$ 输出格式：输出一行$n$个整数，第$i$个整数表示第$i$个字符串的答案。 输入输出样例输入样例：3 1abcaab 输出样例：6 1 3 分析广义$SAM$模板题(应该是)。不知道为什么，用了快读读数字，再用cin读string就爆炸了。 参考资料广义$SAM$dwjshift的 用SAM建广义后缀树 提供在线和离线建法。话说这篇资料里提到的不在Trie上建$SAM$是怎么做的？？？wangzhen_yu的 广义后缀自动机 提供很好的例题及代码讲解。以前不懂什么叫进行内容更新菜啊phile的 关于广义后缀树（多串SAM）的总结 本题自为风月马前卒的题解 主要参考题解，这篇题解是枚举前缀的后缀(即子串)进行内容更新，而不是插入时更新，换句话说，这篇题解是从上至下更新，而不是一般的插入时从下至上更新。clover_hxy的 题解 这篇题解是在建自动机的时候统计的每个状态的出现次数，最后求答案时连边跳，本过没看懂其中的mark数组是干什么的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 100010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,m,las,cnt=1,times[maxn&lt;&lt;1],sum[maxn&lt;&lt;1],vis[maxn&lt;&lt;1],len[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26];string str[maxn];void add(int cc)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][cc];p=fa[p])ch[p][cc]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][cc]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; fa[nq]=fa[q]; len[nq]=len[p]+1; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][cc]==q;p=fa[p])ch[p][cc]=nq; &#125; &#125;&#125;void dfs(int x)&#123; if(!x||vis[x])return ; vis[x]=true; dfs(fa[x]); sum[x]+=sum[fa[x]];&#125;void GetTimes()&#123; for(int i=1;i&lt;=n;i++) &#123; int now=1; for(int j=0;j&lt;(int)str[i].length();j++) &#123; now=ch[now][str[i][j]-'a']; int tmp=now; while(tmp&amp;&amp;vis[tmp]!=i) &#123; vis[tmp]=i; times[tmp]+=1; tmp=fa[tmp]; &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; las=1; cin&gt;&gt;str[i]; for(int j=0;j&lt;(int)str[i].length();j++)add(str[i][j]-'a'); &#125; GetTimes(); for(int i=1;i&lt;=cnt;i++)sum[i]=(times[i]&gt;=m)*(len[i]-len[fa[i]]); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=cnt;i++)dfs(i); for(int i=1;i&lt;=n;i++) &#123; int ans=0,now=1; for(int j=0;j&lt;(int)str[i].length();j++) now=ch[now][str[i][j]-'a'],ans+=sum[now]; printf("%d ",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P4022 [CTSC2012]熟悉的文章]]></title>
    <url>%2F2019%2F04%2F21%2FP4022-CTSC2012-%E7%86%9F%E6%82%89%E7%9A%84%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[P4022 [CTSC2012]熟悉的文章传送门洛谷 题目描述阿米巴是小强的好朋友。 在小强眼中，阿米巴是一个作文成绩很高的文艺青年。为了获取考试作文的真谛，小强向阿米巴求教。阿米巴给小强展示了几篇作文，小强觉得这些文章怎么看怎么觉得熟悉，仿佛是某些范文拼拼凑凑而成的。小强不禁向阿米巴投去了疑惑的眼光，却发现阿米巴露出了一个狡黠的微笑。 为了有说服力地向阿米巴展示阿米巴的作文是多么让人觉得“眼熟”，小强想出了一个评定作文 “熟悉程度”的量化指标：L 0 .小强首先将作文转化成一个 01 串。之后，小强搜集了各路名家的文章，同样分别转化成 01 串后，整理出一个包含了 M 个 01 串的“ 标准作文库 ”。 小强认为：如果一个 01 串长度不少于 L 且在 标准作文库 中的某个串里出现过（即，它是 标准作文库 的 某个串 的一个 连续子串 ），那么它是“ 熟悉 ”的。对于一篇作文（一个 01 串）A，如果能够把 A 分割成若干段子串，其中“ 熟悉 ” 的子串的 长度 总 和 不少于 A 总 长度的 90%，那么称 A 是 “ 熟悉的文章 ”。 L 0 是 能够让 A 成为 “ 熟悉的文章 ” 的 所有 L 的最大值 （如果不存在这样的 L，那么规定 L 0 =0）。 举个例子： 小强的作文库里包含了如下 2 个字符串： 10110000001110有一篇待考察的作文是： 1011001100小强计算出这篇作文 L 的最大值是 4，因为待考察的作文可以视作’10110’+’0110’+’0’，其中’10110’和’0110’被判定为 “ 熟悉 ” 的。而当 L = 5 或是更大的时候，不存在符合题意的分割方法。所以，这篇作文的 L 0 = 4。小强认为阿米巴作文的 L 0 值比其他同学的明显要大。请你帮他验证一下。 输入输出格式输入格式：输入文件 cheat.in 第一行是两个整数 N, M，表示待检查的作文数量，和小强的标准作文库的行数。 接下来是 M 行的 01 串，表示标准作文库。 接下来是 N 行的 01 串，表示 N 篇作文。 输出格式：输出文件 cheat.out 包含 N 行，每一行包含一个整数，表示该篇作文的 L 0 值。 输入输出样例输入样例#1：1 2101100000011101011001100 输出样例#1：4 说明对于 30%的测试数据，输入文件的长度不超过 1000 字节。 对于 50%的测试数据，输入文件的长度不超过 61000 字节。 对于 80%的测试数据，输入文件的长度不超过 250000 字节。 对于 100%的测试数据，输入文件的长度不超过 1100000 字节。 分析$0pts：$不打或打炸。看到求最小的最大值，想到二分。证明一波：很明显，对于大的可行的串，它的小的子串一定也可行(即，对于一个可行的L,小于它的L一定也可行)，反之不一定成立，满足单调性，所以可以二分。那么怎么$check$呢？？？想到DP。我们设$f_i$表示以$i$位置结尾时题意要求的最大值。很容易写出转移方程如下： f_j=max(f_i-1,f_j+i-(j+1)+1),j \in [i-len_i,i-L]其中，$len_i$表示符合题意要求的分割的最大值，即以$i$结尾的可以被匹配的01串的最大值。直接搞，$60pts$到手。但转念想想，正解(如果也是用这个DP方程的话)不可能直接暴力转移，不然就满分了，不会才$60pts$。如果想要通过本题的话，复杂度应该是在$O(nlogn)$左右。那么转移应该做到$O(1)$才行。想想把$O(n)$的DP转移优化为$O(1)$的方法就那么几种。再发现两个边界($i-len_i$,$i-L$)中第一个边界肯定是单调不降的，第二个边界是单调上升的，很容易理解和证明，这里省去证明。于是想到单调队列优化DP。稍微化一下式子就行了。DP处理完了。想一想$len_i$怎么求，发现这个东西在广义$SAM$上跑一下就行了。另外，在打代码的时候注意一下循环语句的执行顺序，我就在把while改for的时候爆炸了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1000010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,m,sl,cnt=1,las,Q[maxn],f[maxn],match[maxn],len[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][2];char str[maxn];void add(int cc)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][cc];p=fa[p])ch[p][cc]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][cc]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; len[nq]=len[p]+1; fa[nq]=fa[q]; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][cc]==q;p=fa[p])ch[p][cc]=nq; &#125; &#125;&#125;void Match()&#123; int p=1,l=0,c; for(int i=1;i&lt;=sl;i++) &#123; c=str[i]-'0'; if(ch[p][c])p=ch[p][c],l+=1; else &#123; for(;p&amp;&amp;!ch[p][c];p=fa[p]); if(p)l=len[p]+1,p=ch[p][c]; else p=1,l=0; &#125; match[i]=l; &#125;&#125;bool check(int L)&#123; int h=1,t=0; for(int i=1;i&lt;=L-1;i++)f[i]=0; for(int i=L;i&lt;=sl;i++) &#123; f[i]=f[i-1]; while(h&lt;=t&amp;&amp;f[Q[t]]-Q[t]&lt;f[i-L]-(i-L))t-=1; Q[++t]=i-L; while(h&lt;=t&amp;&amp;Q[h]&lt;i-match[i])h+=1; if(h&lt;=t)f[i]=max(f[i],f[Q[h]]+i-Q[h]); &#125; return f[sl]*10&gt;=sl*9;&#125;int main()&#123; read(n,m); for(int i=1;i&lt;=m;i++) &#123; las=1; scanf("%s",str+1); sl=strlen(str+1); for(int j=1;j&lt;=sl;j++)add(str[j]-'0'); &#125; for(int tot=1;tot&lt;=n;tot++) &#123; scanf("%s",str+1); sl=strlen(str+1); Match(); int l=0,r=sl,ans=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid))ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>CTSC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3649 [APIO2014]回文串]]></title>
    <url>%2F2019%2F04%2F21%2FP3649-APIO2014-%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[P3649 [APIO2014]回文串传送门洛谷 题目描述给你一个由小写拉丁字母组成的字符串 $s$。我们定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。 对于给你的这个字符串 $s$，求所有回文子串中的最大存在值。 输入输出格式输入格式：一行，一个由小写拉丁字母（a~z）组成的非空字符串 $s$。 输出格式：输出一个整数，表示所有回文子串中的最大存在值。 输入输出样例输入样例#1：abacaba 输出样例#1：7 输入样例#2：www 输出样例#2：4 说明【样例解释1】用 $\lvert s \rvert$ 表示字符串 s 的长度。 一个字符串 $s_1 s_2 \dots s_{\lvert s \rvert}$的子串是一个非空字符串 $s_i s_{i+1} \dots s_j$，其中 $1 \leq i \leq j \leq \lvert s \rvert$。每个字符串都是自己的子串。 一个字符串被称作回文串当且仅当这个字符串从左往右读和从右往左读都是相同的。 这个样例中，有 $7$ 个回文子串 a，b，c，aba，aca，bacab，abacaba。他们的存在值分别为 $4, 2, 1, 6, 3, 5, 7$。 所以回文子串中最大的存在值为 $7$。 第一个子任务共 8 分，满足 $1 \leq \lvert s \rvert \leq 100$。 第二个子任务共 15 分，满足 $1 \leq \lvert s \rvert \leq 1000$。 第三个子任务共 24 分，满足 $1 \leq \lvert s \rvert \leq 10000$。 第四个子任务共 26 分，满足 $1 \leq \lvert s \rvert \leq 100000$。 第五个子任务共 27 分，满足 $1 \leq \lvert s \rvert \leq 300000$。 分析看到“定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度“,第一反应这不是P3804的定义吗。于是…嗯…$SAM$！！！其实是因为我是搜$SAM$的标签搜到的这题嗯…打一发…哦~过了样例。开心ing…交一发….等等！开不开long long。算一波极限,赋值一下,编译器告诉我—-overflow in implicit constant conversion。哦~看来要开long long。交一发….额~50分？？？为什么只有50分？？？我的$SAM$打错了？？？懵逼ing…哦~回文串嘛。为什么直接求所有子串的存在值有50分？？？可是回文串怎么做？？？题解….$SAM$套$Manacher$加倍增？？？好麻烦不打，复杂度还是$O(nlogn)$的，还被卡空间….嗯~纯$SAM$的，可是…图呢？？？没图我怎么知道你在说什么？？？网上一搜…又搜到一篇…还是没图(确切的说，是当时没图)…放弃…颓废ing…算了，回文自动机正等着我…学习ing…发现我的回文自动机没初始化特殊字符？？？(即$s_0=-1$)，还是过了？？？算了，不再交了，放代码的时候加上算了。 参考资料纯$SAM$Leaves的题解asuldb的题解 回文自动机大奕哥&amp;VANE的 Palindromic Tree 回文自动机-回文树 例题+讲解 主要学习资料Clove_unique的 Manacher 回文自动机 学习笔记 主要是为了看图冯钰恒的 回文树/回文自动机/PAM总结——题解 P3649 【[APIO2014]回文串】 主要参考代码实现F.W.Nietzsche的 回文树或者回文自动机，及相关例题KSKUN的 回文自动机原理与实现 Updateasuldb的题解刷新一波又有图了，于是再学…为什么我做的时候你没图，做完就有图了！！！ 代码第一份傻逼的错误代码写了这么久好歹还是放一下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 300010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,las=1,cnt=1,ton[maxn&lt;&lt;1],ns[maxn&lt;&lt;1],len[maxn&lt;&lt;1],siz[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26];long long ans;char str[maxn];void add(int c)&#123; int p=las,np=las=++cnt; siz[np]=1; len[np]=len[p]+1; for(;p&amp;&amp;!ch[p][c];p=fa[p])ch[p][c]=np; if(!p)fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; fa[nq]=fa[q]; len[nq]=len[p]+1; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[q]=fa[np]=nq; for(;p&amp;&amp;ch[p][c]==q;p=fa[p])ch[p][c]=nq; &#125; &#125;&#125;int main()&#123; scanf("%s",str);n=strlen(str); for(int i=0;i&lt;n;i++)add(str[i]-'a'); for(int i=1;i&lt;=cnt;i++)ton[len[i]]+=1; for(int i=1;i&lt;=cnt;i++)ton[i]+=ton[i-1]; for(int i=1;i&lt;=cnt;i++)ns[ton[len[i]]--]=i; for(int i=cnt;i&gt;=1;i--) &#123; siz[fa[ns[i]]]+=siz[ns[i]]; ans=max(ans,1ll*len[ns[i]]*siz[ns[i]]); &#125; printf("%lld\n",ans); return 0;&#125; 回文自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define maxn 300010using namespace std;template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int n,cnt,last,pos,s[maxn],fail[maxn],len[maxn],Count[maxn],ch[maxn][26];long long ans;char str[maxn];void Init()&#123; len[0]=0; len[1]=-1; fail[0]=1; s[0]=-1; //之前交的时候没加这个，现在补上 cnt=1; last=0;&#125;int Get(int k)&#123; while(s[pos]!=s[pos-len[k]-1])k=fail[k]; return k;&#125;void add(int cc)&#123; s[++pos]=cc; int x=Get(last); if(!ch[x][cc]) &#123; int y=++cnt; len[y]=len[x]+2; fail[y]=ch[Get(fail[x])][cc]; ch[x][cc]=y; &#125; last=ch[x][cc]; Count[last]+=1;&#125;int main()&#123; scanf("%s",str); n=strlen(str); Init(); for(int i=0;i&lt;n;i++)add(str[i]-'a'); for(int i=cnt;i&gt;1;i--) &#123; Count[fail[i]]+=Count[i]; ans=max(ans,1ll*Count[i]*len[i]); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>APIO</tag>
        <tag>模板</tag>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3975 [TJOI2015]弦论]]></title>
    <url>%2F2019%2F04%2F18%2FP3975-TJOI2015-%E5%BC%A6%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[P3975 [TJOI2015]弦论传送门洛谷 题目描述为了提高智商,ZJY开始学习弦论。这一天,她在《 String theory》中看到了这样一道问题:对于一个给定的长度为n的字符串,求出它的第k小子串是什么。你能帮帮她吗? 输入输出格式输入格式：第一行是一个仅由小写英文字母构成的字符串s 第二行为两个整数t和k,t为0则表示不同位置的相同子串算作一个,t为1则表示不同位置的相同子串算作多个。k的意义见题目描述。 输出格式：输出数据仅有一行,该行有一个字符串,为第k小的子串。若子串数目不足k个,则输出-1。 输入输出样例输入样例#1：aabc0 3 输出样例#1：aab 输入样例#2：aabc1 3 输出样例#2：aa 输入样例#3：aabc1 11 输出样例#3：-1 说明数据范围对于$10\%$的数据，$n \le 1000$。 对于$50\%$的数据，$t = 0$。 对于$100\%$的数据，$n \le 5 × 10^5, t &lt; 2, k \le 10^9$。 分析T=0时，设$siz_i=1$，即出现次数设为1。T=1时，将$siz_i$设为$Endpos$的大小，即出现次数。 之前在想如果复制的点不设置$siz_i$，最终统计时是否会出现$siz_i=0$的情况。网上说不会。那就自己yy一下。因为复制的点一定有子树，而$siz_i$是子树中终止节点的个数。那么我们就需要就证明子树中一定有至少一个终止节点。因为它有子树，说明有终止节点(感觉像没证一样，但换个角度想想，我们又不傻，如果它的子树内没有终止节点，那么我们还建子树干嘛，只会平白浪费时间和空间)。所以得证。正确性不保证，自己什么都不懂，没有理论支持，自己yy自然没法保证正确性…如果有人发现这个假了，或者有正确性保证的证明，请评论告诉我，谢谢。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 500010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;int T,k,las=1,cnt=1,siz[maxn&lt;&lt;1],sum[maxn&lt;&lt;1],ch[maxn&lt;&lt;1][26],len[maxn&lt;&lt;1],fa[maxn&lt;&lt;1],tong[maxn&lt;&lt;1],ns[maxn&lt;&lt;1];char str[maxn];void add(int c)&#123; int p=las,np=las=++cnt; len[np]=len[p]+1; siz[cnt]=1; while(p&amp;&amp;!ch[p][c])ch[p][c]=np,p=fa[p]; if(!p)fa[np]=1; else &#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[np]=q; else &#123; int nq=++cnt; memcpy(ch[nq],ch[q],sizeof(ch[q])); fa[nq]=fa[q]; len[nq]=len[p]+1; fa[q]=fa[np]=nq; while(p&amp;&amp;ch[p][c]==q)ch[p][c]=nq,p=fa[p]; &#125; &#125;&#125;void pre()&#123; for(int i=1;i&lt;=cnt;i++)tong[len[i]]++; for(int i=1;i&lt;=cnt;i++)tong[i]+=tong[i-1]; for(int i=1;i&lt;=cnt;i++)ns[tong[len[i]]--]=i; for(int i=cnt;i&gt;=1;i--) if(T)siz[fa[ns[i]]]+=siz[ns[i]]; else siz[i]=1; siz[1]=0; for(int i=cnt;i&gt;=1;i--) &#123; sum[ns[i]]=siz[ns[i]]; for(int j=0;j&lt;26;j++) if(ch[ns[i]][j]) sum[ns[i]]+=sum[ch[ns[i]][j]]; &#125;&#125;void solve()&#123; if(k&gt;sum[1]) &#123; puts("-1"); return ; &#125; int now=1; k-=siz[now]; while(k) &#123; int i=0; while(k&gt;sum[ch[now][i]]) k-=sum[ch[now][i]],i+=1; now=ch[now][i]; putchar('a'+i); k-=siz[now]; &#125;&#125;int main()&#123; scanf("%s",str); read(T,k); int len=strlen(str); for(int i=0;i&lt;len;i++)add(str[i]-'a'); pre(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3804 后缀自动机]]></title>
    <url>%2F2019%2F04%2F17%2FP3804-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[P3804 后缀自动机传送门洛谷 题目描述给定一个只包含小写字母的字符串$S$, 请你求出 $S$ 的所有出现次数不为 1 的子串的出现次数乘上该子串长度的最大值。 输入输出格式输入格式：一行一个仅包含小写字母的字符串$S$ 输出格式：一个整数，为 所求答案 输入输出样例输入样例#1：abab 输出样例#1：4 说明对于$10\%$的数据，$\lvert S \rvert \le 1000$对于$100\%$的数据，$\lvert S \rvert \le 10^6$ 分析既然是后缀自动机模板，自然用后缀自动机来做，具体的，就是建立后缀自动机，然后再Parent树上DFS，答案为子树大小*节点的len长度的最大值。 Update：以前没能弄清为什么siz[…]=1写在建后缀自动机里就行，写在DFS里就挂，后来Achen告诉我有些点没有siz值。 后缀自动机入门 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define maxn 1000010template &lt;typename T&gt;inline T read()&#123; register T sum=0; register char cc=getchar(); int sym=1; while(cc!='-'&amp;&amp;(cc&gt;'9'||cc&lt;'0'))cc=getchar(); if(cc=='-')sym=-1,cc=getchar(); sum=sum*10+cc-'0'; cc=getchar(); while(cc&gt;='0'&amp;&amp;cc&lt;='9')sum=sum*10+cc-'0',cc=getchar(); return sym*sum;&#125;template &lt;typename T&gt;inline T read(T &amp;a)&#123; a=read&lt;T&gt;(); return a;&#125;template &lt;typename T,typename... Others&gt; inline void read(T&amp; a, Others&amp;... b)&#123; a=read(a); read(b...);&#125;struct Node&#123; int fa; int len; int ch[30];&#125;node[maxn&lt;&lt;1];struct Edge&#123; int v; Edge *next; Edge(int a=0,Edge *b=NULL) &#123; v=a; next=b; &#125;&#125;*head[maxn&lt;&lt;1];int len,tot=1,las=1;long long ans,siz[maxn&lt;&lt;1];char str[maxn];void add(int c)&#123; int p=las,np=las=++tot; siz[tot]=1; node[np].len=node[p].len+1; for(;p&amp;&amp;!node[p].ch[c];p=node[p].fa)node[p].ch[c]=np; if(!p)node[np].fa=1; else &#123; int q=node[p].ch[c]; if(node[q].len==node[p].len+1)node[np].fa=q; else &#123; int nq=++tot; node[nq]=node[q]; node[nq].len=node[p].len+1; node[q].fa=node[np].fa=nq; for(;p&amp;&amp;node[p].ch[c]==q;p=node[p].fa)node[p].ch[c]=nq; &#125; &#125;&#125;void dfs(int k)&#123; for(Edge *i=head[k];i!=NULL;i=i-&gt;next) &#123; dfs(i-&gt;v); siz[k]+=siz[i-&gt;v]; &#125; if(siz[k]!=1)ans=max(ans,siz[k]*node[k].len);&#125;int main()&#123; scanf("%s",str); len=strlen(str); for(int i=0;i&lt;len;i++)add(str[i]-'a'); for(int i=2;i&lt;=tot;i++)head[node[i].fa]=new Edge(i,head[node[i].fa]); dfs(1); printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>模板</tag>
      </tags>
  </entry>
</search>
